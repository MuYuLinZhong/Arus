# Go 语法与依赖库入门

**面向对 Go、Gin、GORM、RabbitMQ 了解较少的开发者**。本文讲解基本概念和在你项目中的典型用法，便于阅读和修改 Promthus 服务端代码。

---

## 目录

1. [Go 语言基础](#1-go-语言基础)
2. [Gin Web 框架](#2-gin-web-框架)
3. [GORM ORM](#3-gorm-orm)
4. [RabbitMQ 消息队列](#4-rabbitmq-消息队列)
5. [在你项目中的串联](#5-在你项目中的串联)

---

## 1. Go 语言基础

### 1.1 包与入口

- 每个 Go 文件属于一个 **包（package）**。可执行程序入口包名必须是 `main`，且包含 `func main()`。
- 导入其他包：`import "promthus/internal/model"`，使用：`model.User`、`model.Fail()`。
- 同一包内不同文件共享命名空间，无需再导入。

**你项目里**：`cmd/main.go` 的 `package main` 和 `func main()` 是程序入口；`internal/model`、`internal/handler` 等是内部包。

### 1.2 基本类型与声明

```go
var count int           // 声明，默认 0
name := "hello"         // 短声明，自动推断类型
var id int64 = 1
const CodeOK = 0
```

常见类型：`int` / `int64`、`string`、`bool`、`float64`、`[]byte`（字节切片）、`error`。

### 1.3 结构体（struct）

结构体相当于「自定义数据类型」，把多个字段绑在一起：

```go
type User struct {
    ID     int64   // 首字母大写 = 包外可访问（导出）
    Name   string
    status int     // 小写 = 仅包内可访问
}
```

使用：

```go
u := User{ID: 1, Name: "张三"}
u.Name = "李四"
p := &u
p.Name = "王五"  // 指针，修改的是同一块内存
```

**你项目里**：`model.User`、`model.Device`、`model.Session` 等都是结构体，对应数据库表。

### 1.4 接口（interface）

接口定义「能做什么」，不关心「是谁」：

```go
type SessionStore interface {
    Create(session *Session) error
    DeleteByJTI(jti uuid.UUID) error
}
```

只要某个类型实现了这些方法，就满足该接口，无需显式声明。这样可以把「具体实现」（如 PostgreSQL）换成别的（如 Redis），而不改调用方代码。

**你项目里**：`repository.SessionStore`、`repository.DeviceFailStore`、`kms.KMS` 都是接口，便于测试和替换实现。

### 1.5 错误处理

Go 没有 try-catch，错误通过返回值传递：

```go
result, err := doSomething()
if err != nil {
    return nil, err   // 向上返回错误
}
// 使用 result
```

常见写法：`if err != nil { ... return }`。`errors.Is(err, gorm.ErrRecordNotFound)` 用于判断是否为「记录不存在」这类已知错误。

### 1.6 指针与 nil

- 指针：`*User` 表示「指向 User 的指针」，`&u` 取地址。
- 未赋值时指针为 `nil`。调用前常做 `if x != nil { x.Do() }`。
- 传指针可避免大结构体拷贝，并允许函数内修改原对象。

### 1.7 并发：goroutine 与 channel

- **goroutine**：轻量级线程，用 `go func() { ... }()` 启动，与主流程并发执行。
- **channel**：用于 goroutine 间传值，`ch := make(chan int)`，`ch <- 1` 发送，`x := <-ch` 接收。

**你项目里**：`lock_service` 里用 `go func() { ... Update("last_active_at") }()` 异步更新数据库，不阻塞 HTTP 响应。

### 1.8 defer

`defer` 把函数调用推迟到当前函数 return 之前执行，常用于释放资源、解锁、恢复 panic：

```go
defer clearBytes(kd)        // 函数退出前清空密钥
defer func() {
    if r := recover(); r != nil { ... }
}()
```

---

## 2. Gin Web 框架

Gin 是 Go 的 HTTP 框架，负责：路由、解析请求、写响应、中间件链。

### 2.1 路由与处理函数

```go
r := gin.Default()
r.GET("/api/health", handler.Health)                    // GET
r.POST("/api/auth/login", authHandler.Login)             // POST
r.PUT("/api/admin/users/:uuid", adminHandler.UpdateUser) // 路径参数 :uuid
```

处理函数签名固定为：`func(c *gin.Context)`。所有请求信息、响应写入都通过 `c` 完成。

### 2.2 Context（c *gin.Context）做什么

- **读请求**：`c.GetHeader("Authorization")`、`c.Query("page")`（URL 查询参数）、`c.Param("uuid")`（路径参数）、`c.ShouldBindJSON(&req)`（把 JSON body 绑定到结构体）。
- **写响应**：`c.JSON(200, data)`、`c.Abort()`（终止后续处理）、`c.Next()`（继续下一个中间件/处理函数）。
- **在链中传值**：`c.Set("user_id", id)`、`c.GetInt64("user_id")`，供后续中间件或 handler 使用。

**你项目里**：登录后 Auth 中间件把 `user_id`、`role` 写入 `c`，admin 的 handler 用 `c.GetInt64("user_id")` 取当前操作人。

### 2.3 中间件（Middleware）

中间件本质是一个「包装函数」：在执行业务逻辑前后做统一处理（鉴权、日志、限流等）。

```go
func Auth() gin.HandlerFunc {
    return func(c *gin.Context) {
        token := c.GetHeader("Authorization")
        if token == "" {
            c.Abort()
            c.JSON(401, ...)
            return
        }
        // 校验 token，设置 c.Set("user_id", ...)
        c.Next()  // 继续执行后面的 handler
    }
}
```

执行顺序：请求 → 中间件1 → 中间件2 → … → 最终 handler → 沿路返回。任一环节 `c.Abort()` 后不再调用 `c.Next()`，直接返回响应。

**你项目里**：`RequestID` → `SecurityHeaders` → `AccessLog` → `GlobalRateLimit` → `Auth` → `RBAC` → handler，见 `router/router.go`。

### 2.4 绑定与校验

`c.ShouldBindJSON(&req)` 会把 JSON body 反序列化到结构体，并利用 `binding` tag 做校验：

```go
type LoginRequest struct {
    Phone    string `json:"phone" binding:"required"`
    Password string `json:"password" binding:"required,min=8"`
}
```

校验失败会返回 `err`，一般对应 400 和「参数错误」提示。

---

## 3. GORM ORM

GORM 用结构体操作数据库，把「表」映射成「模型（Model）」，用方法代替手写 SQL（也支持 Raw SQL）。

### 3.1 模型与表名

结构体字段通过 tag 和数据库列对应：

```go
type User struct {
    ID          int64     `gorm:"primaryKey"`
    UUID        uuid.UUID `gorm:"type:uuid"`
    Phone       string    `gorm:"uniqueIndex"`
    PasswordHash string
    CreatedAt   time.Time
}
```

实现 `TableName() string` 可指定表（含 schema）：`return "app.users"`。这样 GORM 生成的 SQL 会带 schema，和你的 PostgreSQL 设计一致。

### 3.2 连接与全局 DB

```go
db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
// 之后用 db.Where(...).First(&user) 等
```

**你项目里**：`repository.InitDB()` 打开连接并赋给全局 `repository.DB`，各处用 `repository.DB.Model(&model.User{}).Where(...)` 查询。

### 3.3 常用操作

| 目的       | 示例 |
|------------|------|
| 按主键/条件查一条 | `db.Where("uuid = ?", id).First(&user)`，找不到返回 `gorm.ErrRecordNotFound` |
| 查列表     | `db.Where("status = ?", 1).Find(&users)` |
| 计数       | `db.Model(&User{}).Where(...).Count(&total)` |
| 创建       | `db.Create(&user)`，主键会写回 `user.ID` |
| 更新       | `db.Model(&user).Updates(map[string]interface{}{"name": "新名字"})` |
| 删除       | `db.Delete(&user)` 或条件删除 |
| 事务       | `db.Transaction(func(tx *gorm.DB) error { ... return nil })`，返回非 nil 会回滚 |

### 3.4 原始 SQL

复杂逻辑可直接写 SQL：`db.Raw("SELECT ... FROM app.rate_limits ...", arg).Scan(&result)`。你项目里限流、device_fail_counts 的 upsert 就用了 Raw。

### 3.5 软删除

字段 `DeletedAt gorm.DeletedAt` 会启用软删除：`Delete` 变成更新 `deleted_at`，普通查询自动加 `deleted_at IS NULL`。你项目里 User、Device 等都用软删除。

---

## 4. RabbitMQ 消息队列

RabbitMQ 是「消息中间件」：生产者发消息到队列，消费者从队列取消息异步处理，实现解耦、削峰、异步。

### 4.1 核心概念

- **Producer（生产者）**：发消息的一方。你的 HTTP 服务在「开锁挑战/上报」后发审计、告警消息。
- **Queue（队列）**：存消息的 FIFO 队列，有名字（如 `audit.queue`），可持久化（durable），重启不丢。
- **Consumer（消费者）**：从队列取消息并处理的进程。你项目里单独进程/协程消费 `audit.queue`，批量写入 `log.audit_logs`。
- **Message（消息）**：通常为 JSON  body，带业务字段（user_id、device_id、action、occurred_at 等）。

不必深究 Exchange、Binding 时，可简化为：**发到指定队列名，从指定队列名消费**。

### 4.2 在你项目中的用法

- **发布**：`publisher.PublishAudit(&AuditMessage{...})` 把审计事件序列化成 JSON，发到 `audit.queue`。HTTP 请求立刻返回，不等待写库。
- **消费**：`AuditConsumer` 从 `audit.queue` 取消息，反序列化成结构体，攒一批（如 100 条或 1 秒）后 `CreateInBatches` 写入 PostgreSQL，然后 ACK 该条消息。
- **好处**：写审计日志不阻塞开锁接口；DB 短暂不可用时消息留在队列，恢复后继续写入；可多实例消费提高吞吐。

### 4.3 常见 API 概念（amqp091-go）

- **连接**：`amqp.Dial(url)` 得到连接，再 `conn.Channel()` 得 channel。
- **声明队列**：`ch.QueueDeclare("audit.queue", true, false, false, false, nil)`，第二个参数 `true` 表示 durable。
- **发消息**：`ch.PublishWithContext(ctx, "", "audit.queue", false, false, amqp.Publishing{ Body: jsonBytes, DeliveryMode: amqp.Persistent })`。
- **消费**：`ch.Consume("audit.queue", ...)` 得到 `<-chan Delivery`，循环读；处理完后 `msg.Ack(false)`，失败可 `msg.Nack(false, false)` 不重入队（或根据策略重试）。

---

## 5. 在你项目中的串联

一次「开锁挑战」请求的路径可以串起上述所有部分：

1. **Gin** 收到 `POST /api/lock/challenge`，依次经过中间件（RequestID、安全头、AccessLog、限流、Auth）。
2. **Auth** 用 Token 从 **GORM** 查 `app.sessions`、`app.users`，把 `user_id` 写入 **Context**。
3. **LockHandler.Challenge** 从 Context 取 `user_id`，用 **c.ShouldBindJSON** 绑定请求体到 `ChallengeRequest`，调用 **LockService.Challenge**。
4. **LockService** 用 **GORM** 查设备、权限，用 **KMS** 解密密钥并计算应答；用 **Publisher** 发审计消息到 **RabbitMQ**；用 **go func()** 异步更新 `last_active_at`。
5. 另一侧 **AuditConsumer** 从 RabbitMQ 取消息，批量用 **GORM** 写入 `log.audit_logs`。
6. **Gin** 通过 `c.JSON(200, response)` 把 `{"response": "hex..."}` 返回给客户端。

这样，**Go** 写业务与并发，**Gin** 管 HTTP，**GORM** 管持久化，**RabbitMQ** 管异步审计，各司其职。遇到具体文件或函数时，可以按「这是路由/中间件/业务/持久化/消息」对号入座，再结合本文概念查阅官方文档深入。
