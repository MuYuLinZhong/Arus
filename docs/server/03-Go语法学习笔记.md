# Go 语法学习笔记

**来源**：学习 Promthus 服务端代码过程中遇到的语法疑问与解答。

---

## 目录

1. [方法接收者（receiver）](#1-方法接收者receiver)
2. [if 短声明 + 条件](#2-if-短声明--条件)
3. [参数列表类型简写](#3-参数列表类型简写)
4. [多返回值赋值](#4-多返回值赋值)
5. [结构体字面量 + 取地址](#5-结构体字面量--取地址)
6. [函数作为参数（回调）](#6-函数作为参数回调)
7. [interface 接口（类比 C++ 抽象基类）](#7-interface-接口类比-c-抽象基类)
8. [空结构体 + 外部挂方法](#8-空结构体--外部挂方法)
9. [空接口 interface{}](#9-空接口-interface)
10. [make 内置函数](#10-make-内置函数)
11. [sync.Once 单次执行](#11-synconce-单次执行)
12. [go 关键字与 goroutine](#12-go-关键字与-goroutine)
13. [channel 与信号等待](#13-channel-与信号等待)
14. [defer 延迟执行](#14-defer-延迟执行)
15. [包名 vs 变量名](#15-包名-vs-变量名)
16. [Gin 中间件：返回函数 vs 直接函数](#16-gin-中间件返回函数-vs-直接函数)
17. [Gin 路由注册与 c.Next/c.Abort](#17-gin-路由注册与-cnextcabort)

---

## 1. 方法接收者（receiver）

**疑问**：`func (c *DatabaseConfig) DSN() string` 是什么写法？

**语法**：

```go
func (接收者变量 接收者类型) 方法名(参数) 返回值 {
    // 方法体
}
```

**含义**：这不是普通函数，而是「挂在某个类型上的方法」。谁调 `.DSN()`，谁就是方法里的 `c`。

```go
// 定义
func (c *DatabaseConfig) DSN() string {
    return "host=" + c.Host + " port=" + c.Port
}

// 调用
cfg.Database.DSN()  // 这次 c = &cfg.Database
```

**类比 C++**：相当于类的成员函数，只不过 Go 把「属于哪个类」写在函数名前面的括号里，而不是写在 class 里面。

---

## 2. if 短声明 + 条件

**疑问**：`if v := os.Getenv(key); v != ""` 是什么语法？

**语法**：

```go
if 初始化语句; 条件 {
    // 条件为 true 时执行
}
```

- 分号前面：声明或赋值，变量只在此 if 块内有效。
- 分号后面：布尔条件。

```go
if v := os.Getenv(key); v != "" {
    return v       // 有环境变量，返回该值
}
return fallback    // 没有或为空，返回默认值
```

---

## 3. 参数列表类型简写

**疑问**：`func envOrDefault(key, fallback string)` 里 `key, fallback string` 是什么？

**含义**：两个参数共用一个类型的简写，等价于 `key string, fallback string`。

```go
func envOrDefault(key, fallback string) string { ... }
// 等价于
func envOrDefault(key string, fallback string) string { ... }
```

---

## 4. 多返回值赋值

**疑问**：`DB, err = gorm.Open(...)` 为什么左边有两个变量？

**含义**：Go 函数可以返回多个值，用逗号分隔接收：

```go
DB, err = gorm.Open(postgres.Open(dsn), &gorm.Config{...})
//  ↑       ↑
// 第一个返回值  第二个返回值
```

- `gorm.Open` 返回 `(*gorm.DB, error)`。
- 左边写两个变量按顺序分别接收。
- 常见的 `n, err := strconv.Atoi(v)` 同理。

---

## 5. 结构体字面量 + 取地址

**疑问**：`&gorm.Config{ Logger: ..., SkipDefaultTransaction: true, PrepareStmt: true }` 是什么写法？

**含义**：

```go
gorm.Config{          // 创建一个 gorm.Config 类型的值
    Logger:    ...,   // 按「字段名: 值」赋值
    PrepareStmt: true,  // 末尾逗号在 Go 里合法（尾随逗号）
}
```

- 前面加 `&`：对这个结构体取地址，得到 `*gorm.Config`（指针），因为 `gorm.Open` 要的是指针。
- 等价于先创建变量再取地址：

```go
cfg := gorm.Config{Logger: ..., PrepareStmt: true}
gorm.Open(driver, &cfg)
```

只是「直接写在参数里」更紧凑。

---

## 6. 函数作为参数（回调）

**疑问**：`func Transaction(fn func(tx *gorm.DB) error) error` 参数里怎么又是个函数？

**含义**：Go 里函数是「一等公民」，可以当参数传。`fn` 的类型是 `func(tx *gorm.DB) error`，即「接收 `*gorm.DB`、返回 `error` 的函数」。

调用时传一个匿名函数：

```go
repository.Transaction(func(tx *gorm.DB) error {
    tx.Model(&device).Update("status", 2)
    tx.Create(&alert)
    return nil    // nil = 提交，非 nil = 回滚
})
```

**设计原因**：GORM 在内部负责 Begin / Commit / Rollback，你只写「在事务里做什么」，不用自己管事务生命周期，也不会漏写 Rollback。

---

## 7. interface 接口（类比 C++ 抽象基类）

**疑问**：`type SessionStore interface { Create(...); FindByJTI(...); ... }` 是什么意思？

**含义**：

- **interface = 一组方法签名**，只规定「能做什么」，不写实现。
- 任何类型只要实现了这些方法，就「满足」该接口，**无需显式声明继承**。
- 业务层统一以接口为入参类型，可传不同实现（PostgresSessionStore、RedisSessionStore）。
- 调用时通过接口的方法表多态到具体实现，类似 C++ 基类指针/虚表分发。

```go
type SessionStore interface {
    Create(session *model.Session) error
    // ...
}

// PostgresSessionStore 实现了全部方法 → 满足 SessionStore
type PostgresSessionStore struct{}
func (s *PostgresSessionStore) Create(session *model.Session) error { ... }

// 业务层依赖接口，不依赖具体实现
func NewAuthService(ss repository.SessionStore) *AuthService { ... }
```

---

## 8. 空结构体 + 外部挂方法

**疑问**：为什么定义一个空结构体 `struct{}`，不把函数写在 struct 内部？

**原因**：

- Go 里 **struct 只能放字段（数据）**，不能在花括号里写函数；方法必须用接收者语法写在类型外面。
- 空结构体是因为当前实现不需要 per-instance 数据（用的是全局 `DB`），但**仍需要一个类型**才能定义接收者方法、实现接口。
- 将来需要「每个实例持有自己的 DB」时，在 struct 里加字段即可。

```go
type PostgresSessionStore struct{}  // 空：不需要字段，用全局 DB

func (s *PostgresSessionStore) Create(session *model.Session) error {
    return DB.Create(session).Error  // 这里 DB 是包级全局变量
}
```

---

## 9. 空接口 interface{}

**疑问**：`func (db *DB) Create(value interface{})` 里 `interface{}` 是什么？

**含义**：

- `interface{}` = **空接口**，没有方法要求，任何类型都满足。
- 参数类型写 `interface{}` = **"可以传任意类型"**。
- GORM 用它是因为 `Create` 既要支持 `&User{}`（单条）又要支持 `&[]User{}`（多条），用空接口统一接收，内部通过**反射或类型断言**判断实际类型再生成 SQL。
- 类比 C++：类似 `void*` 或 `std::any`，但比 `void*` 类型安全（运行时可拿到真实类型信息）。

---

## 10. make 内置函数

**疑问**：`key = make([]byte, 32)` 里 `make` 是什么方法？

**含义**：Go 的**内置函数**（不是方法，不用导包），专门用来创建 **slice、map、channel** 这三种类型：

```go
make([]byte, 32)          // 长度 32 的字节切片，初始全 0
make(map[string]int)      // 空 map
make(chan os.Signal, 1)   // 带缓冲 1 的 channel
```

- `make` 和 `new` 的区别：`make` 返回初始化好的 slice/map/channel（不是指针）；`new(T)` 返回指向零值的指针 `*T`。
- 切片**必须**用 `make`（或字面量 `[]byte{...}`）创建，`new([]byte)` 得到的是指向 nil 切片的指针，不能当切片用。

---

## 11. sync.Once 单次执行

**疑问**：`var once sync.Once` 是什么写法？

**含义**：

- `sync.Once` 是标准库 `sync` 包里的类型，保证 `once.Do(func() { ... })` 里的函数**在多 goroutine 下也只执行一次**。
- 声明 `var once sync.Once` 后，配合 `once.Do(fn)`，第一次调会执行 `fn`，之后再调 `Do` 直接跳过。

```go
var once sync.Once

func Init(path string) {
    once.Do(func() {
        // 这里只会执行一次，无论 Init 被调几次、几个 goroutine 同时调
        key, _ := os.ReadFile(path)
        instance = &LocalKMS{masterKey: key}
    })
}
```

---

## 12. go 关键字与 goroutine

**疑问**：`go func() { ... }()` 和 `go startSessionCleaner(...)` 里的 `go` 是什么？

**含义**：

- **`go 函数调用`**：在一个新的 **goroutine**（轻量级线程）里执行该调用；当前 goroutine 不等它结束，立刻继续往下。
- **goroutine**：由 Go 运行时调度，开销小（几 KB 栈），一个进程可以起很多个。

```go
// 匿名函数 + go：在后台启动 HTTP 监听
go func() {
    srv.ListenAndServe()  // 阻塞，但在另一个 goroutine 里，不卡 main
}()

// 普通函数 + go：在后台跑定时清理
go startSessionCleaner(sessionStore)
```

- 不加 `go`：main 会阻塞在 `ListenAndServe()` 或死循环里，后面的代码永远执行不到。
- 加了 `go`：后台跑，main 可以继续做「等信号、优雅关机」。

---

## 13. channel 与信号等待

**疑问**：`quit := make(chan os.Signal, 1)` + `signal.Notify(quit, ...)` + `<-quit` 是什么语法？

**含义**：

- **channel**：goroutine 之间传值的管道。`make(chan os.Signal, 1)` 创建容量为 1 的 channel。
- **signal.Notify(quit, SIGINT, SIGTERM)**：把系统信号转发到 `quit` 这个 channel；收到信号时会往 quit 里写一个值。
- **`<-quit`**：从 channel 读一个值；若 channel 为空则**阻塞**，直到有值可读。

```go
quit := make(chan os.Signal, 1)                    // 造一个 channel
signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM) // 信号来了就往 quit 里塞
<-quit                                              // main 阻塞在这里，收到信号后继续
// 下面是优雅关机逻辑...
```

- **容量为 1**：避免信号发出时没人读而丢信号。
- 这是 Go 里**等退出信号**的标准写法。

---

## 14. defer 延迟执行

**含义**：`defer 函数调用` 把该调用推迟到**当前函数 return 之前**执行，常用于释放资源、清理等。

```go
func main() {
    logger.Init(cfg.Server.Mode)
    defer logger.Sync()       // main 退出前刷日志

    repository.InitDB(...)
    defer repository.CloseDB() // main 退出前关 DB

    // ... 中间还有 defer publisher.Close() 等
}
```

- 多个 defer 按**后进先出（LIFO）**顺序执行：最后注册的最先执行。
- 即使 panic，已注册的 defer 也会执行（配合 recover 捕获异常）。

---

## 15. 包名 vs 变量名

**疑问**：`repository.InitDB(...)` 里的 `repository` 不是变量，找不到定义？

**含义**：

- `repository` 是**包名**，不是变量。来自 import：`"promthus/internal/repository"`，包名取路径最后一段 `repository`。
- `repository.InitDB(...)` 表示：调用 `repository` 包里的 `InitDB` 函数。
- 包名在该包目录下某个 `.go` 文件的 `package repository` 声明。

```go
import "promthus/internal/repository"  // 导入包

repository.InitDB(...)  // repository 是包名，不是变量
cfg.Database            // cfg 是变量（在 main 里用 := 定义的）
```

---

## 16. Gin 中间件：返回函数 vs 直接函数

**疑问**：`func Auth() gin.HandlerFunc { return func(c *gin.Context) { ... } }` 为什么不直接写 `func Auth(c *gin.Context)`？

**解答**：

- **直接写可以**：对无参数的 Auth，`func Auth(c *gin.Context) { ... }` + `r.Use(Auth)` 完全合法。
- **包一层的原因**：
  1. 和 RBAC("admin")、RateLimiter(cfg) 等「带参数、返回 HandlerFunc」的中间件**保持统一写法**：挂载全是 `r.Use(XXX())`。
  2. 以后 Auth 加参数（如 `Auth(opts *AuthOptions)`）时，不用改 Use 的写法。
- Auth() 本身**无入参**；有入参 `c *gin.Context` 的是**Auth() 返回的那个函数**，由 Gin 在每次请求时传入 `c`。

---

## 17. Gin 路由注册与 c.Next/c.Abort

**疑问**：路由里为什么能传两个 handler？`c.Next()` 和 `c.Abort()` 是什么？

**路由可以绑多个 handler**：

```go
auth.POST("/login", middleware.LoginRateLimit(), authHandler.Login)
//                    ↑ 第一个（中间件）            ↑ 第二个（业务handler）
```

- Gin 会按顺序执行：先 LoginRateLimit()，再 authHandler.Login。
- 中间件里调 **c.Next()** 才会继续执行链上下一个 handler。

**c.Next()**：

- 执行链上「下一个」以及之后所有 handler；等它们都执行完再返回到当前函数。
- 利用这一点可以在 c.Next() 前后分别做「请求前」和「请求后」的逻辑（如 Prometheus 耗时统计）。

**c.Abort()**：

- 告诉 Gin：不再执行后面的 handler，当前请求到此为止。
- 通常配合 `model.Fail(c, status, code, msg)` 写响应后使用，表示「校验失败，直接返回错误」。

**r.Use(中间件) vs 路由上写多个 handler**：

| 方式 | 作用范围 |
|------|----------|
| `r.Use(...)` 或 `group.Use(...)` | 该引擎或该组下**所有路由**都经过 |
| `r.POST(path, h1, h2)` | 只有**这一条路由**经过 h1、h2 |

---

> ※ 本笔记对应 Promthus 服务端代码学习过程，后续遇到新语法可继续追加。
