# 数据库总体设计说明书

**防盗安全预警系列 · 石油阀门 NFC 智能管控系统**

| 项目 | 内容 |
|------|------|
| 文档版本 | V2.0 |
| 编制日期 | 2026年2月 |
| 适用范围 | 数据库架构、多租户隔离、设备与用户分组、终端设备管理、权限模型、日志与业务数据分离 |
| 依据 | 从《Web 端技术设计说明书》中剥离并增强的数据库专项设计 |

---

## 目录

1. [设计目标与原则](#1-设计目标与原则)
2. [库与 Schema 划分](#2-库与-schema-划分)
3. [分库分表策略](#3-分库分表策略)
4. [设备模型与类型扩展](#4-设备模型与类型扩展)
5. [业务库表设计](#5-业务库表设计)
6. [日志与审计库表设计](#6-日志与审计库表设计)
7. [监控与数据流表设计](#7-监控与数据流表设计)
8. [ER 与依赖关系](#8-er-与依赖关系)
9. [迁移与演进路径](#9-迁移与演进路径)
10. [部分库表拆解升级考虑](#10-部分库表拆解升级考虑)
11. [版本记录](#11-版本记录)

---

## 1. 设计目标与原则

### 1.1 核心目标

- **多租户数据隔离**：多家公司共用一套系统，每家公司（租户）的用户、设备、权限、告警完全隔离，不可跨租户查看或操作。
- **解耦可持续演进**：业务数据、日志数据、监控数据分离，避免单库单表膨胀与耦合。
- **设备类型可扩展**：后续新增设备类型时，通过独立表或扩展表接入，不污染现有表结构。
- **分组批量授权**：支持设备分组与用户分组，实现「用户组 × 设备组」的批量权限管理。
- **分库分表就绪**：表结构与命名预留分片键与分区键，便于后续扩展。

### 1.2 设计原则

| 原则 | 说明 |
|------|------|
| 租户隔离优先 | 所有业务实体表必须包含 `tenant_id`，所有查询必须带租户条件；应用层中间件强制注入，防止跨租户泄漏。 |
| 业务与日志分离 | 业务库只存「当前状态」与「业务实体关系」；审计、操作日志放入独立 Schema。 |
| 日志与监控分离 | 审计日志、时序指标分表或分库存储，便于按数据类型做保留策略与查询优化。 |
| 设备类型隔离 | 每种设备类型使用独立表，避免单表字段爆炸；新类型通过新增表 + 类型注册接入。 |
| 分区与分片友好 | 大表统一使用明确的分区键，便于后续做库内分区或跨库分片。 |

### 1.3 术语定义

| 术语 | 定义 |
|------|------|
| 租户（Tenant） | 一家使用本系统的公司/组织，拥有独立的用户、设备、权限空间。 |
| 租户管理员（tenant_admin） | 每家公司的超级管理员，可管理公司内所有用户、设备、分组和权限。 |
| 业务库 | 存储用户、会话、设备元数据、权限、告警等「当前状态」的 Schema。 |
| 日志库 | 存储审计日志、操作日志等「只追加、不修改」的 Schema。 |
| 设备类型 | 如 lock（锁具）、terminal（终端设备）等，每种类型对应独立业务表。 |
| 终端设备（Terminal） | 第三方备用 NFC 终端（当前为树莓派 Zero 2W），绑定到管理员账户，替代手机 NFC 功能。 |

---

## 2. 库与 Schema 划分

### 2.1 推荐划分方式

优先采用 **单库多 Schema** 起步，为后续拆库预留清晰边界：

| 逻辑域 | Schema 名称 | 用途 | 是否可独立拆库 |
|--------|-------------|------|----------------|
| 业务 | `app` | 租户、用户、会话、设备、分组、权限、告警、限流等 | 是 |
| 日志 | `log` | 审计日志、操作日志、系统访问日志 | 是 |
| 监控与数据流 | `metrics` | 时序指标、数据监控流、采集记录（预留） | 是 |

### 2.2 分离带来的好处

- **业务库**：可做常规备份、事务一致性要求高；表结构变更与业务发布绑定。
- **日志库**：只追加、可按时间分区与归档；保留策略与业务库独立。
- **监控/数据流库**：写入量大时可单独扩容，不影响业务库稳定性。

### 2.3 跨 Schema 引用约定

- 业务表之间使用 **同一 Schema 内主键/外键**。
- 日志表、监控表 **不建立指向业务表的外键**，仅存储业务实体的 ID 或编码，避免业务表变更影响日志。
- 日志表存储 `tenant_id` 用于租户级筛选，但不做外键约束。

---

## 3. 分库分表策略

### 3.1 当前阶段（单库多 Schema）

- 单实例 PostgreSQL，使用 Schema 区分 `app`、`log`、`metrics`。
- 大表在库内做 **分区表**（如按 `occurred_at` 月分区）。
- 所有业务表包含 `tenant_id`，为后续按租户分片预留。

### 3.2 未来分库方向

| 维度 | 说明 |
|------|------|
| 按域分库 | 将 `app`、`log`、`metrics` 拆成三个物理库。 |
| 按租户分片 | 租户数量增大时，按 `tenant_id` 做水平分片。 |
| 按设备类型分表 | 设备相关表已按类型分表，天然支持按类型分库。 |
| 按时间分片 | 日志与监控表按 `occurred_at` 分片，便于冷热分离。 |

### 3.3 分表键与分区键约定

| 表类型 | 建议分区/分片键 | 说明 |
|--------|-----------------|------|
| 审计/操作日志 | `occurred_at`（月或季度） | 按时间分区，历史分区可整体归档。 |
| 监控/时序表 | `ts`（按天/周） | 时序查询为主。 |
| 业务表 | `tenant_id` | 未来按租户分片时的分片键。 |

---

## 4. 设备模型与类型扩展

### 4.1 设计思路

- **不采用** 单一大宽表 `devices` 承载所有设备类型。
- **采用** 「设备类型注册 + 按类型分表」：每种设备类型一张业务表，便于按类型扩展字段与索引。
- 所有设备表包含 `tenant_id`，设备归属租户。

### 4.2 设备类型注册表

```sql
CREATE TABLE app.device_types (
    id          SMALLSERIAL PRIMARY KEY,
    code        VARCHAR(32) NOT NULL UNIQUE,   -- 'lock', 'terminal', 'sensor' ...
    name        VARCHAR(100) NOT NULL,
    table_name  VARCHAR(64) NOT NULL,
    description TEXT,
    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

INSERT INTO app.device_types (code, name, table_name) VALUES
('lock', 'NFC锁具', 'devices_lock'),
('terminal', '备用NFC终端', 'devices_terminal');
-- 后续扩展：('sensor', '传感器', 'devices_sensor');
```

### 4.3 按类型分表：锁具表

```sql
CREATE TABLE app.devices_lock (
    id              BIGSERIAL PRIMARY KEY,
    tenant_id       BIGINT NOT NULL REFERENCES app.tenants(id),
    device_id       VARCHAR(32) NOT NULL,
    name            VARCHAR(100) NOT NULL,
    location_text   TEXT NOT NULL,
    longitude       NUMERIC(10,7),
    latitude        NUMERIC(10,7),
    pipeline_tag    VARCHAR(50),
    risk_level      SMALLINT NOT NULL DEFAULT 1,
    key_encrypted   BYTEA NOT NULL,
    key_version     SMALLINT NOT NULL DEFAULT 1,
    status          SMALLINT NOT NULL DEFAULT 1,
    last_active_at  TIMESTAMPTZ,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at      TIMESTAMPTZ
);

CREATE UNIQUE INDEX idx_devices_lock_tid_did  ON app.devices_lock(tenant_id, device_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_devices_lock_pipeline        ON app.devices_lock(tenant_id, pipeline_tag);
CREATE INDEX idx_devices_lock_status          ON app.devices_lock(tenant_id, status) WHERE deleted_at IS NULL;
```

### 4.4 按类型分表：终端设备表

终端设备（Terminal）为第三方备用 NFC 终端（当前为树莓派 Zero 2W），当管理员手机没电或无 NFC 功能时作为替代设备使用。终端绑定到管理员账户（方案 B），开机即可工作，无需现场登录。

```sql
CREATE TABLE app.devices_terminal (
    id                BIGSERIAL PRIMARY KEY,
    tenant_id         BIGINT NOT NULL REFERENCES app.tenants(id),
    device_id         VARCHAR(32) NOT NULL,
    name              VARCHAR(100) NOT NULL,
    device_model      VARCHAR(50) NOT NULL DEFAULT 'rpi_zero_2w',
    location_text     TEXT,
    secret_hash       VARCHAR(100) NOT NULL,         -- Argon2id(device_secret)
    bound_user_id     BIGINT REFERENCES app.users(id),
    status            SMALLINT NOT NULL DEFAULT 0,   -- 0=待激活 1=启用 2=锁定 3=禁用
    last_active_at    TIMESTAMPTZ,
    firmware_version  VARCHAR(20),
    target_firmware   VARCHAR(20),                    -- 待更新的目标版本，NULL=无更新
    capabilities      JSONB,
    created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at        TIMESTAMPTZ
);

CREATE UNIQUE INDEX idx_devices_terminal_tid_did ON app.devices_terminal(tenant_id, device_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_devices_terminal_status         ON app.devices_terminal(tenant_id, status) WHERE deleted_at IS NULL;
CREATE INDEX idx_devices_terminal_bound_user     ON app.devices_terminal(tenant_id, bound_user_id) WHERE deleted_at IS NULL;
```

### 4.5 设备全局唯一性

**约定**：
- **同一租户、同一类型内**：`device_id` 唯一（如 `(tenant_id, device_id)` 在 `devices_lock` 中唯一）。
- **跨租户**：不同租户可拥有相同 `device_id`（各公司独立管理设备编号）。
- **全局标识**：用 **(tenant_id, device_type, device_id)** 三元组唯一标识一台设备。

---

## 5. 业务库表设计（app Schema）

### 5.1 租户表（app.tenants）

```sql
CREATE TABLE app.tenants (
    id          BIGSERIAL PRIMARY KEY,
    code        VARCHAR(32) NOT NULL UNIQUE,   -- 短码，如 'acme', 'petrochina'
    name        VARCHAR(200) NOT NULL,
    status      SMALLINT NOT NULL DEFAULT 1,   -- 0=停用 1=启用
    contact     VARCHAR(50),
    phone       VARCHAR(20),
    max_users   INT NOT NULL DEFAULT 100,
    max_devices INT NOT NULL DEFAULT 500,
    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**设计说明**：
- 租户为系统级实体，由平台运营方创建（或通过注册流程），不属于任何租户。
- `max_users` / `max_devices` 为配额上限，应用层在创建用户/设备时校验不超限。

### 5.2 用户表（app.users）

```sql
CREATE TABLE app.users (
    id            BIGSERIAL PRIMARY KEY,
    tenant_id     BIGINT NOT NULL REFERENCES app.tenants(id),
    uuid          UUID NOT NULL DEFAULT gen_random_uuid(),
    phone         VARCHAR(20) NOT NULL,
    password_hash VARCHAR(100) NOT NULL,
    name          VARCHAR(50) NOT NULL,
    department    VARCHAR(100),
    role          VARCHAR(20) NOT NULL,    -- 'tenant_admin' | 'admin' | 'operator'
    status        SMALLINT NOT NULL DEFAULT 1,
    created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at    TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at    TIMESTAMPTZ
);

CREATE UNIQUE INDEX idx_users_uuid             ON app.users(uuid);
CREATE UNIQUE INDEX idx_users_tenant_phone     ON app.users(tenant_id, phone) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_tenant_status_role      ON app.users(tenant_id, status, role) WHERE deleted_at IS NULL;
```

**角色层级**：

| 角色 | 权限范围 | 说明 |
|------|---------|------|
| `tenant_admin` | 租户内全部 | 公司超级管理员，每个租户至少一个；可管理用户、设备、分组、权限、终端 |
| `admin` | 租户内管理 | 普通管理员，可管理用户和设备（受 tenant_admin 约束） |
| `operator` | 仅操作授权设备 | 普通操作员，只能操作被授权的锁具 |

**手机号唯一性**：同一租户内手机号唯一；不同租户可存在相同手机号（同一人可能同时在多家公司任职）。

### 5.3 会话表（app.sessions）

```sql
CREATE TABLE app.sessions (
    id          BIGSERIAL PRIMARY KEY,
    jti         UUID NOT NULL,
    user_id     BIGINT NOT NULL REFERENCES app.users(id),
    tenant_id   BIGINT NOT NULL,
    role        VARCHAR(20) NOT NULL,
    client_type VARCHAR(20) NOT NULL DEFAULT 'web',  -- 'web' | 'mobile' | 'tablet'
    expires_at  TIMESTAMPTZ NOT NULL,
    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    user_agent  VARCHAR(200),
    ip_address  INET
);

CREATE UNIQUE INDEX idx_sessions_jti      ON app.sessions(jti);
CREATE INDEX idx_sessions_user_id         ON app.sessions(user_id);
CREATE INDEX idx_sessions_tenant_id       ON app.sessions(tenant_id);
CREATE INDEX idx_sessions_expires         ON app.sessions(expires_at);
```

### 5.4 设备会话表（app.device_sessions）

终端设备独立于用户的会话管理：

```sql
CREATE TABLE app.device_sessions (
    id          BIGSERIAL PRIMARY KEY,
    jti         UUID NOT NULL,
    device_id   VARCHAR(32) NOT NULL,
    device_type VARCHAR(32) NOT NULL DEFAULT 'terminal',
    tenant_id   BIGINT NOT NULL,
    expires_at  TIMESTAMPTZ NOT NULL,
    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    ip_address  INET
);

CREATE UNIQUE INDEX idx_device_sessions_jti        ON app.device_sessions(jti);
CREATE INDEX idx_device_sessions_device_id         ON app.device_sessions(device_id);
CREATE INDEX idx_device_sessions_tenant_id         ON app.device_sessions(tenant_id);
CREATE INDEX idx_device_sessions_expires           ON app.device_sessions(expires_at);
```

### 5.5 设备分组表（app.device_groups + app.device_group_members）

将锁具等设备编入分组，便于批量授权。

```sql
CREATE TABLE app.device_groups (
    id          BIGSERIAL PRIMARY KEY,
    tenant_id   BIGINT NOT NULL REFERENCES app.tenants(id),
    name        VARCHAR(100) NOT NULL,
    description TEXT,
    created_by  BIGINT NOT NULL REFERENCES app.users(id),
    status      SMALLINT NOT NULL DEFAULT 1,
    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_device_groups_tenant_name ON app.device_groups(tenant_id, name) WHERE status = 1;

CREATE TABLE app.device_group_members (
    id          BIGSERIAL PRIMARY KEY,
    group_id    BIGINT NOT NULL REFERENCES app.device_groups(id) ON DELETE CASCADE,
    device_type VARCHAR(32) NOT NULL,
    device_id   VARCHAR(32) NOT NULL,
    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_dgm_unique ON app.device_group_members(group_id, device_type, device_id);
CREATE INDEX idx_dgm_device        ON app.device_group_members(device_type, device_id);
```

**设计说明**：
- 一台设备可属于多个分组（如 LOCK-001 同时在「油田A阀门组」和「高风险设备组」中）。
- 分组名称在租户内唯一。
- `device_group_members` 通过 `(device_type, device_id)` 引用设备，不用外键，与权限表设计一致。

### 5.6 用户分组表（app.user_groups + app.user_group_members）

将用户编入分组，便于批量授权。

```sql
CREATE TABLE app.user_groups (
    id          BIGSERIAL PRIMARY KEY,
    tenant_id   BIGINT NOT NULL REFERENCES app.tenants(id),
    name        VARCHAR(100) NOT NULL,
    description TEXT,
    created_by  BIGINT NOT NULL REFERENCES app.users(id),
    status      SMALLINT NOT NULL DEFAULT 1,
    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_user_groups_tenant_name ON app.user_groups(tenant_id, name) WHERE status = 1;

CREATE TABLE app.user_group_members (
    id          BIGSERIAL PRIMARY KEY,
    group_id    BIGINT NOT NULL REFERENCES app.user_groups(id) ON DELETE CASCADE,
    user_id     BIGINT NOT NULL REFERENCES app.users(id),
    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_ugm_unique ON app.user_group_members(group_id, user_id);
CREATE INDEX idx_ugm_user          ON app.user_group_members(user_id);
```

### 5.7 权限授权表（app.permissions）

**V2.0 重大改造**：支持四种授权组合——用户/用户组 × 设备/设备组。

```sql
CREATE TABLE app.permissions (
    id              BIGSERIAL PRIMARY KEY,
    tenant_id       BIGINT NOT NULL REFERENCES app.tenants(id),

    -- 授权主体（二选一）
    user_id         BIGINT REFERENCES app.users(id),
    user_group_id   BIGINT REFERENCES app.user_groups(id),

    -- 授权客体（二选一）
    device_type     VARCHAR(32),
    device_id       VARCHAR(32),
    device_group_id BIGINT REFERENCES app.device_groups(id),

    granted_by      BIGINT NOT NULL REFERENCES app.users(id),
    valid_from      TIMESTAMPTZ NOT NULL,
    valid_until     TIMESTAMPTZ,
    status          SMALLINT NOT NULL DEFAULT 1,
    revoked_by      BIGINT REFERENCES app.users(id),
    revoked_at      TIMESTAMPTZ,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT chk_perm_subject CHECK (
        (user_id IS NOT NULL AND user_group_id IS NULL) OR
        (user_id IS NULL AND user_group_id IS NOT NULL)
    ),
    CONSTRAINT chk_perm_object CHECK (
        (device_type IS NOT NULL AND device_id IS NOT NULL AND device_group_id IS NULL) OR
        (device_type IS NULL AND device_id IS NULL AND device_group_id IS NOT NULL)
    )
);

-- 四种组合各自的唯一约束
CREATE UNIQUE INDEX idx_perm_user_device
    ON app.permissions(tenant_id, user_id, device_type, device_id)
    WHERE user_id IS NOT NULL AND device_type IS NOT NULL AND status = 1;

CREATE UNIQUE INDEX idx_perm_user_devgroup
    ON app.permissions(tenant_id, user_id, device_group_id)
    WHERE user_id IS NOT NULL AND device_group_id IS NOT NULL AND status = 1;

CREATE UNIQUE INDEX idx_perm_ugroup_device
    ON app.permissions(tenant_id, user_group_id, device_type, device_id)
    WHERE user_group_id IS NOT NULL AND device_type IS NOT NULL AND status = 1;

CREATE UNIQUE INDEX idx_perm_ugroup_devgroup
    ON app.permissions(tenant_id, user_group_id, device_group_id)
    WHERE user_group_id IS NOT NULL AND device_group_id IS NOT NULL AND status = 1;

CREATE INDEX idx_perm_tenant_status ON app.permissions(tenant_id, status);
CREATE INDEX idx_perm_user_id       ON app.permissions(user_id) WHERE user_id IS NOT NULL;
CREATE INDEX idx_perm_user_group_id ON app.permissions(user_group_id) WHERE user_group_id IS NOT NULL;
CREATE INDEX idx_perm_device        ON app.permissions(device_type, device_id) WHERE device_type IS NOT NULL;
CREATE INDEX idx_perm_dev_group_id  ON app.permissions(device_group_id) WHERE device_group_id IS NOT NULL;
```

**四种授权类型说明**：

| 主体 | 客体 | 示例 | 适用场景 |
|------|------|------|---------|
| 用户 | 单设备 | "张三 → 锁具 LOCK-001" | 精确控制，少量设备 |
| 用户 | 设备组 | "张三 → 油田A阀门组" | 用户需访问整组设备 |
| 用户组 | 单设备 | "巡检队A → 锁具 LOCK-001" | 多人共用一台设备 |
| 用户组 | 设备组 | "巡检队A → 油田A阀门组" | 最常用：整组人员访问整组设备 |

**挑战-应答时的权限查询**（热路径，需高效）：

```sql
-- 检查用户 $2 在租户 $1 下是否有权限操作设备 ($3, $4)
SELECT EXISTS (
    SELECT 1 FROM app.permissions p
    WHERE p.tenant_id = $1 AND p.status = 1
      AND p.valid_from <= NOW()
      AND (p.valid_until IS NULL OR p.valid_until > NOW())
      AND (
          -- 路径1：用户 → 设备
          (p.user_id = $2 AND p.device_type = $3 AND p.device_id = $4)
          OR
          -- 路径2：用户 → 设备组（含该设备）
          (p.user_id = $2 AND p.device_group_id IN (
              SELECT group_id FROM app.device_group_members
              WHERE device_type = $3 AND device_id = $4
          ))
          OR
          -- 路径3：用户组（含该用户）→ 设备
          (p.device_type = $3 AND p.device_id = $4 AND p.user_group_id IN (
              SELECT group_id FROM app.user_group_members WHERE user_id = $2
          ))
          OR
          -- 路径4：用户组（含该用户）→ 设备组（含该设备）
          (p.user_group_id IN (
              SELECT group_id FROM app.user_group_members WHERE user_id = $2
          ) AND p.device_group_id IN (
              SELECT group_id FROM app.device_group_members
              WHERE device_type = $3 AND device_id = $4
          ))
      )
) AS has_permission;
```

用户通常只属于少数几个组，设备也只属于少数几个组，因此子查询返回行数极少，配合索引可快速短路。

### 5.8 终端-锁具绑定表（app.terminal_lock_bindings）

控制终端设备可操作的锁具范围。支持绑定单锁具或设备组。

```sql
CREATE TABLE app.terminal_lock_bindings (
    id              BIGSERIAL PRIMARY KEY,
    tenant_id       BIGINT NOT NULL REFERENCES app.tenants(id),
    terminal_id     VARCHAR(32) NOT NULL,       -- devices_terminal.device_id

    -- 绑定目标（二选一）
    lock_device_id  VARCHAR(32),                -- 单锁具
    device_group_id BIGINT REFERENCES app.device_groups(id),

    granted_by      BIGINT NOT NULL REFERENCES app.users(id),
    status          SMALLINT NOT NULL DEFAULT 1,
    valid_from      TIMESTAMPTZ NOT NULL,
    valid_until     TIMESTAMPTZ,
    revoked_by      BIGINT REFERENCES app.users(id),
    revoked_at      TIMESTAMPTZ,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT chk_binding_target CHECK (
        (lock_device_id IS NOT NULL AND device_group_id IS NULL) OR
        (lock_device_id IS NULL AND device_group_id IS NOT NULL)
    )
);

CREATE INDEX idx_terminal_bindings_terminal ON app.terminal_lock_bindings(tenant_id, terminal_id) WHERE status = 1;
CREATE INDEX idx_terminal_bindings_lock     ON app.terminal_lock_bindings(lock_device_id) WHERE lock_device_id IS NOT NULL AND status = 1;
CREATE INDEX idx_terminal_bindings_group    ON app.terminal_lock_bindings(device_group_id) WHERE device_group_id IS NOT NULL AND status = 1;
```

### 5.9 告警记录表（app.alerts）

```sql
CREATE TABLE app.alerts (
    id          BIGSERIAL PRIMARY KEY,
    tenant_id   BIGINT NOT NULL REFERENCES app.tenants(id),
    alert_type  VARCHAR(40) NOT NULL,
    device_type VARCHAR(32) NOT NULL DEFAULT 'lock',
    device_id   VARCHAR(32) NOT NULL,
    user_id     BIGINT REFERENCES app.users(id),
    severity    SMALLINT NOT NULL,
    status      SMALLINT NOT NULL DEFAULT 0,
    handled_by  BIGINT REFERENCES app.users(id),
    handle_note TEXT,
    extra       JSONB,
    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    handled_at  TIMESTAMPTZ
);

CREATE INDEX idx_alerts_tenant_status      ON app.alerts(tenant_id, status) WHERE status = 0;
CREATE INDEX idx_alerts_device_created     ON app.alerts(tenant_id, device_id, created_at DESC);
CREATE INDEX idx_alerts_severity_status    ON app.alerts(tenant_id, severity, status);
```

### 5.10 限流与状态表

```sql
CREATE TABLE app.rate_limits (
    key          VARCHAR(150) PRIMARY KEY,
    count        INT NOT NULL DEFAULT 1,
    window_start TIMESTAMPTZ NOT NULL,
    updated_at   TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE app.device_fail_counts (
    tenant_id     BIGINT NOT NULL,
    device_type   VARCHAR(32) NOT NULL,
    device_id     VARCHAR(32) NOT NULL,
    count         INT NOT NULL DEFAULT 0,
    last_fail_at  TIMESTAMPTZ NOT NULL,
    updated_at    TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (tenant_id, device_type, device_id)
);

CREATE TABLE app.ip_blocks (
    ip          INET PRIMARY KEY,
    blocked_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at  TIMESTAMPTZ NOT NULL,
    reason      VARCHAR(100)
);
CREATE INDEX idx_ip_blocks_expires ON app.ip_blocks(expires_at);
```

### 5.11 OTA 固件包表（app.ota_packages）

管理终端设备的固件更新包：

```sql
CREATE TABLE app.ota_packages (
    id              BIGSERIAL PRIMARY KEY,
    tenant_id       BIGINT NOT NULL REFERENCES app.tenants(id),
    version         VARCHAR(20) NOT NULL,
    device_model    VARCHAR(50) NOT NULL DEFAULT 'rpi_zero_2w',
    download_url    TEXT NOT NULL,
    checksum_sha256 VARCHAR(64) NOT NULL,
    release_notes   TEXT,
    created_by      BIGINT NOT NULL REFERENCES app.users(id),
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_ota_pkg_tenant_version ON app.ota_packages(tenant_id, device_model, version);
```

OTA 流程：管理员上传新版本 → 选择目标终端或全部 → 更新 `devices_terminal.target_firmware` → 终端心跳时检测到新版本 → 下载并安装 → 上报新 `firmware_version`。

---

## 6. 日志与审计库表设计（log Schema）

**原则**：所有「只追加、不修改」的审计与操作类数据放入 `log` Schema；存储 `tenant_id` 用于租户级筛选，但不做外键约束。

### 6.1 开锁审计日志（log.audit_logs）

```sql
CREATE TABLE log.audit_logs (
    id           BIGSERIAL,
    tenant_id    BIGINT NOT NULL,
    user_id      BIGINT NOT NULL,
    device_id    VARCHAR(32) NOT NULL,
    device_type  VARCHAR(32) NOT NULL DEFAULT 'lock',
    action       VARCHAR(30) NOT NULL,
    result_code  SMALLINT NOT NULL,
    client_ip    INET NOT NULL,
    device_model VARCHAR(100),
    extra        JSONB,
    occurred_at  TIMESTAMPTZ NOT NULL
) PARTITION BY RANGE (occurred_at);

CREATE TABLE log.audit_logs_2026_02 PARTITION OF log.audit_logs
    FOR VALUES FROM ('2026-02-01') TO ('2026-03-01');

CREATE INDEX idx_audit_logs_tenant      ON log.audit_logs(tenant_id);
CREATE INDEX idx_audit_logs_user_id     ON log.audit_logs(tenant_id, user_id);
CREATE INDEX idx_audit_logs_device_id   ON log.audit_logs(tenant_id, device_id);
CREATE INDEX idx_audit_logs_occurred_at ON log.audit_logs(occurred_at);
CREATE INDEX idx_audit_logs_action      ON log.audit_logs(action);
```

### 6.2 管理员操作日志（log.operation_logs）

```sql
CREATE TABLE log.operation_logs (
    id              BIGSERIAL PRIMARY KEY,
    tenant_id       BIGINT NOT NULL,
    operator_id     BIGINT NOT NULL,
    action          VARCHAR(50) NOT NULL,
    target_type     VARCHAR(20) NOT NULL,
    target_id       BIGINT NOT NULL,
    before_snapshot JSONB,
    after_snapshot  JSONB,
    occurred_at     TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_op_logs_tenant    ON log.operation_logs(tenant_id);
CREATE INDEX idx_op_logs_operator  ON log.operation_logs(tenant_id, operator_id);
CREATE INDEX idx_op_logs_occurred  ON log.operation_logs(occurred_at);
```

### 6.3 访问/请求日志（log.access_logs，可选）

```sql
CREATE TABLE log.access_logs (
    id          BIGSERIAL,
    request_id  UUID NOT NULL,
    method      VARCHAR(10) NOT NULL,
    path        VARCHAR(500) NOT NULL,
    status      SMALLINT NOT NULL,
    client_ip   INET NOT NULL,
    tenant_id   BIGINT,
    user_id     BIGINT,
    latency_ms  INT,
    occurred_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
) PARTITION BY RANGE (occurred_at);
```

---

## 7. 监控与数据流表设计（metrics Schema）

与 V1.x 一致，为多种数据监控流预留独立 Schema。所有表增加 `tenant_id` 字段用于租户级筛选。

### 7.1 设备监控指标表（预留）

```sql
CREATE TABLE metrics.device_metrics (
    id          BIGSERIAL,
    tenant_id   BIGINT NOT NULL,
    device_type VARCHAR(32) NOT NULL,
    device_id   VARCHAR(32) NOT NULL,
    metric_name VARCHAR(64) NOT NULL,
    value       NUMERIC(20,6) NOT NULL,
    unit        VARCHAR(20),
    ts          TIMESTAMPTZ NOT NULL DEFAULT NOW()
) PARTITION BY RANGE (ts);

CREATE INDEX idx_device_metrics_tenant_device_ts ON metrics.device_metrics(tenant_id, device_type, device_id, ts);
```

### 7.2 数据采集流表（预留）

```sql
CREATE TABLE metrics.data_ingestion_logs (
    id           BIGSERIAL PRIMARY KEY,
    tenant_id    BIGINT NOT NULL,
    stream_type  VARCHAR(64) NOT NULL,
    source       VARCHAR(128),
    record_count INT NOT NULL DEFAULT 0,
    status       VARCHAR(20) NOT NULL,
    extra        JSONB,
    started_at   TIMESTAMPTZ NOT NULL,
    finished_at  TIMESTAMPTZ
);
```

---

## 8. ER 与依赖关系

### 8.1 业务库（app）核心关系

```
app.tenants
  ├── app.users (tenant_id)
  ├── app.devices_lock (tenant_id)
  ├── app.devices_terminal (tenant_id)
  ├── app.device_groups (tenant_id)
  ├── app.user_groups (tenant_id)
  ├── app.permissions (tenant_id)
  ├── app.terminal_lock_bindings (tenant_id)
  ├── app.alerts (tenant_id)
  └── app.ota_packages (tenant_id)

app.users
  ├── app.sessions (user_id)
  ├── app.permissions (user_id, granted_by, revoked_by)
  ├── app.user_group_members (user_id)
  ├── app.devices_terminal (bound_user_id)
  ├── app.terminal_lock_bindings (granted_by, revoked_by)
  ├── app.alerts (user_id, handled_by)
  └── log.operation_logs (operator_id)  [跨 Schema，仅存 ID]

app.device_groups
  ├── app.device_group_members (group_id)
  ├── app.permissions (device_group_id)
  └── app.terminal_lock_bindings (device_group_id)

app.user_groups
  ├── app.user_group_members (group_id)
  └── app.permissions (user_group_id)

app.devices_lock / app.devices_terminal / ...
  ├── app.permissions (device_type + device_id，无 FK)
  ├── app.device_group_members (device_type + device_id，无 FK)
  ├── app.terminal_lock_bindings (lock_device_id / terminal_id，无 FK)
  ├── app.device_fail_counts (tenant_id, device_type, device_id)
  └── app.alerts (device_type, device_id)

app.devices_terminal
  └── app.device_sessions (device_id)
```

### 8.2 租户隔离原则

- 所有业务表查询**必须**携带 `WHERE tenant_id = ?`。
- 应用层 Auth 中间件从 Session/Token 中提取 `tenant_id`，注入 Context；Service 层从 Context 获取，禁止由客户端传入。
- 日志表的 `tenant_id` 仅用于筛选，不做外键。

### 8.3 日志库（log）与业务库

- `log.audit_logs`、`log.operation_logs` 仅存 `tenant_id`、`user_id`、`device_id` 等，**无外键**。
- 查询时由应用层按 ID 关联业务表。

---

## 9. 迁移与演进路径

### 9.1 从 V1.x 单租户迁移到 V2.0 多租户

1. 创建 `app.tenants` 表，插入一条默认租户（代表原有的唯一公司）。
2. 为所有现有业务表增加 `tenant_id` 列，填充默认租户 ID。
3. 重建包含 `tenant_id` 的唯一索引（如 `users.phone` → `(tenant_id, phone)`）。
4. 创建新表：`device_groups`、`user_groups`、`*_members`、`devices_terminal`、`device_sessions`、`terminal_lock_bindings`、`ota_packages`。
5. 迁移现有 `permissions` 数据到新结构（原有记录 `user_id` + `device_type` + `device_id` 对应新表的「用户→设备」类型）。
6. 日志表增加 `tenant_id` 列。

### 9.2 设备类型扩展步骤

1. 在 `app.device_types` 增加新类型。
2. 新建 `app.devices_<新类型>` 表（含 `tenant_id`）。
3. 权限表的四种组合对新类型直接可用。
4. 审计、告警、限流、失败计数均已含 `device_type` + `tenant_id`。

### 9.3 后续拆库

- 将 `app`、`log`、`metrics` 分别迁至独立实例；按 `tenant_id` 做水平分片。
- 日志与监控表已按时间分区，可进一步做冷热分离。

---

## 10. 部分库表拆解升级考虑

与 V1.x 一致，核心要点：

| 要点 | 说明 |
|------|------|
| **先拆 log → 再拆 metrics → 最后拆 app** | 风险递增，log 无被引用 FK，最安全。 |
| **事务边界** | 拆库后无跨库事务，涉及多库流程用补偿或重试。 |
| **双写与切换** | 迁移期双写新旧库，校验一致后切读流量。 |
| **租户级分片** | app 拆库时可按 `tenant_id` 范围分片，同一租户数据在同一分片内，避免跨分片事务。 |
| **回滚准备** | 保留旧库/旧表一段时间，配置化数据源便于灰度回滚。 |

---

## 11. 版本记录

| 版本 | 日期 | 变更说明 |
|------|------|----------|
| V1.0 | 2026-02-20 | 初版：库/Schema 划分、分库分表策略、设备类型分表、日志与业务分离。 |
| V1.1 | 2026-02-20 | 权限表改为 (device_type, device_id)；device_fail_counts 主键改为 (device_type, device_id)。 |
| V1.2 | 2026-02-20 | 权限表 device_id 改用业务编号替代主键。 |
| V1.3 | 2026-02-23 | 新增网关设备表、设备会话表、网关-锁具绑定表。 |
| V2.0 | 2026-02-23 | **架构重构**：① 多租户（tenants 表 + 所有业务表增加 tenant_id + 租户隔离原则）；② 角色层级（tenant_admin / admin / operator）；③ 分组模型（device_groups + user_groups + members 表）；④ 权限 4-way 改造（用户/用户组 × 设备/设备组，CHECK 约束 + 四组唯一索引）；⑤ 终端设备（gateway 重命名为 terminal，方案B 绑定账户，增加 target_firmware 字段）；⑥ OTA 固件包表；⑦ terminal_lock_bindings 支持设备组绑定；⑧ 全部日志/监控表增加 tenant_id。 |

---

> ※ 本文档为数据库专项设计基准，后续表结构变更须同步更新并记录变更历史。
