# Web 端技术设计说明书

**Technical Design Specification — Web Platform**
防盗安全预警系列 · 石油阀门 NFC 智能管控系统

| 项目 | 内容 |
|------|------|
| 文档版本 | V1.0 |
| 依据文档 | SRS 软件规格需求说明书 V1.2 |
| 编制日期 | 2026年2月 |
| 适用范围 | Go 服务端开发 + Vue 3 前端开发 |
| 技术栈 | Go + Gin + PostgreSQL（初期），Redis 作为弹性扩展选项 |

---

## 目录

1. [文档说明](#1-文档说明)
2. [整体架构设计](#2-整体架构设计)
3. [数据库设计](#3-数据库设计)
4. [Session 会话管理设计](#4-session-会话管理设计)
5. [限流控制设计](#5-限流控制设计)
6. [核心业务逻辑设计](#6-核心业务逻辑设计)
7. [并发控制设计](#7-并发控制设计)
8. [接口设计规范](#8-接口设计规范)
9. [消息队列设计](#9-消息队列设计)
10. [安全设计](#10-安全设计)
11. [告警系统设计](#11-告警系统设计)
12. [前端架构设计](#12-前端架构设计)
13. [日志与可观测性](#13-日志与可观测性)
14. [部署架构设计](#14-部署架构设计)
15. [Redis 弹性扩展方案](#15-redis-弹性扩展方案)
16. [性能基准与测试要求](#16-性能基准与测试要求)

---

## 1. 文档说明

### 1.1 编写目的

本文档是防盗安全预警系列 Web 端（服务端 + 管控平台前端）的详细技术设计说明书，依据 SRS V1.2 编写，面向架构师与开发人员。目标是明确系统各层次的设计决策、模块边界、数据模型、并发控制策略及接口契约，使开发人员无需反复对齐需求即可独立展开工作。

### 1.2 系统边界说明

**本文档覆盖：**
- Go 服务端：所有业务逻辑、挑战-应答协议计算、权限控制、日志审计、告警推送
- Vue 3 管控平台前端：Web 管理界面，供管理员使用
- 基础设施层：PostgreSQL 数据库、RabbitMQ 消息队列、Grafana Loki 日志

**不在本文档范围内：**
- Flutter 移动端（App 侧）
- MCU 固件与硬件电路设计

### 1.3 技术选型原则

初期采用 **Go + PostgreSQL** 的精简架构，不引入 Redis。原因：

- 流量初期较小，PostgreSQL 完全可以承载 Session 查询和限流计数
- 减少基础设施复杂度，降低运维门槛
- 通过接口抽象隔离数据访问层，后续引入 Redis 时业务代码零修改

Redis 作为**弹性扩展选项**，当出现明确性能瓶颈时再引入（判断标准见第 15 节）。

### 1.4 术语定义

| 术语 | 定义 |
|------|------|
| `K_d` | 设备唯一 AES-128 密钥，出厂烧录于 MCU，服务端密钥库持有加密副本 |
| `C`（挑战数） | MCU TRNG 每次上电生成的 8 字节随机数，仅存活于本次上电 RAM，断电消失 |
| `Response` | 服务端用 K_d 计算的 AES-128-CMAC 值，返回给 App 后由 App 转发 MCU 校验 |
| `JTI` | JWT Token ID，每次登录生成的唯一 UUID，用于标识一条 Session 记录 |
| `RBAC` | 基于角色的访问控制，角色分为：普通用户（user）、管理员（admin） |
| Session | 服务端存储的"Token ↔ 用户信息"映射关系，代表一次已登录的会话 |
| 限流窗口 | 限流计数器的时间单位，窗口内请求超限则拒绝，窗口过期后计数重置 |

---

## 2. 整体架构设计

### 2.1 架构分层

系统采用四层架构，各层职责严格分离，禁止跨层调用：

```
┌─────────────────────────────────────────────────────┐
│                    接入层（Nginx）                     │
│         TLS 终止 · 静态文件 · 反向代理 · IP黑名单        │
└─────────────────────┬───────────────────────────────┘
                      │ HTTP
┌─────────────────────▼───────────────────────────────┐
│               应用层（Go + Gin）                       │
│    路由分发 · 中间件链 · Controller · 参数校验           │
└─────────────────────┬───────────────────────────────┘
                      │ 函数调用
┌─────────────────────▼───────────────────────────────┐
│                  领域层（Service）                     │
│    核心业务规则 · 权限校验 · 挑战-应答 · 告警判定         │
│    不依赖任何框架，可独立单元测试                         │
└──────────┬──────────────────────┬───────────────────┘
           │                      │
┌──────────▼──────────┐  ┌────────▼──────────────────┐
│  基础设施层（数据库）  │  │    基础设施层（消息/日志）    │
│  PostgreSQL 主库     │  │    RabbitMQ · Loki        │
│  PostgreSQL 只读副本  │  │    Prometheus             │
└─────────────────────┘  └───────────────────────────┘
```

| 层次 | 组件 | 职责边界 |
|------|------|---------|
| 接入层 | Nginx | TLS 终止、静态文件分发、API 反向代理、IP 黑名单 |
| 应用层 | Go + Gin | 路由分发、中间件链（鉴权/日志/限流/恢复）、Controller 处理请求 |
| 领域层 | Go Service | 核心业务规则，不依赖任何框架，通过 Repository 接口访问数据 |
| 基础设施层 | PostgreSQL / RabbitMQ / Loki | 数据持久化、异步消息、日志聚合 |

### 2.2 服务端模块划分

| 模块 | 路由前缀 | 职责说明 |
|------|---------|---------|
| Auth 模块 | `/api/auth` | 用户登录、登出、Session 管理，与 NFC 挑战凭证完全隔离 |
| Lock 模块 | `/api/lock` | 挑战-应答计算（核心）、开锁结果上报、授权设备列表查询 |
| Admin 模块 | `/api/admin` | 用户 CRUD、锁具管理、权限授权/撤销、日志查询、告警处置 |
| Notify 模块 | 内部 | 消费 RabbitMQ 告警队列，推送通知，无对外 HTTP 路由 |
| Audit 模块 | 内部 | 消费 RabbitMQ 审计队列，异步写入审计日志表 |

### 2.3 请求处理中间件链

所有 HTTP 请求经过统一的中间件链，任一环节失败即短路返回，不继续执行后续处理：

```
请求到达
  │
  ▼
① Recovery（恢复）
  捕获 panic，返回 500，防止进程崩溃
  │
  ▼
② RequestID
  生成唯一 UUID 注入 Context 和响应头 X-Request-ID
  │
  ▼
③ AccessLog
  记录请求方法、路径、IP、耗时、状态码（JSON 格式）
  │
  ▼
④ RateLimiter
  查询 rate_limits 表，按 IP 或业务维度限流（见第5节）
  超限 → 429 Too Many Requests
  │
  ▼
⑤ Auth（鉴权）
  验证 Authorization Bearer Token
  查 sessions 表确认会话有效性
  无效 → 401 Unauthorized
  │
  ▼
⑥ RBAC（权限）
  根据角色校验路由访问权限
  普通用户访问 Admin 路由 → 403 Forbidden
  │
  ▼
⑦ Controller
  参数绑定与校验，调用 Service 层，封装统一响应
```

### 2.4 统一响应格式

所有接口响应统一包装，前端和 App 均依赖此结构：

```json
{
  "code": 0,
  "message": "success",
  "data": { ... },
  "request_id": "550e8400-e29b-41d4-a716-446655440000",
  "timestamp": 1708300000000
}
```

| 字段 | 类型 | 说明 |
|------|------|------|
| `code` | int | 业务状态码，0 表示成功，非 0 为业务错误 |
| `message` | string | 人类可读描述，错误时返回错误原因 |
| `data` | any / null | 业务数据，错误时为 null |
| `request_id` | string | 本次请求唯一 ID，用于日志关联排查 |
| `timestamp` | int64 | 服务端 Unix 毫秒时间戳 |

**业务错误码规范：**

| 范围 | 类型 |
|------|------|
| `1xxx` | 认证类（登录失败、会话过期） |
| `2xxx` | 权限类（无权访问、权限已撤销） |
| `3xxx` | 锁具操作类（设备不存在、挑战失败、限流） |
| `4xxx` | 参数校验类（缺少字段、格式错误） |
| `5xxx` | 服务内部错误（数据库异常、KMS 异常） |

---

## 3. 数据库设计

### 3.1 PostgreSQL 配置

主数据库采用 **PostgreSQL 15**。

**选型理由：**
- 原生 JSONB 字段支持审计日志扩展字段，可按 JSON Key 建索引查询
- 行级锁（`SELECT FOR UPDATE`）精准控制并发写入
- 分区表天然适配时序型审计数据
- `INSERT ... ON CONFLICT DO UPDATE`（Upsert）原生支持，简化幂等写入

**关键配置项：**

| 配置项 | 推荐值 | 说明 |
|-------|-------|------|
| `max_connections` | 200 | 配合 PgBouncer 连接池，Go 应用连接池最大 50 |
| `shared_buffers` | 物理内存 25% | 如 4GB 内存配置 1GB |
| `effective_cache_size` | 物理内存 75% | 影响查询计划器索引使用决策 |
| `wal_level` | `replica` | 支持流式复制，为主备切换做准备 |
| `log_min_duration_statement` | `200ms` | 慢查询日志，超过 200ms 的 SQL 自动记录 |
| `timezone` | `Asia/Shanghai` | 统一时区，避免夏令时歧义 |

**Go 连接池配置（GORM + pgx 驱动）：**

| 参数 | 值 | 说明 |
|------|---|------|
| `SetMaxOpenConns` | 50 | 最大打开连接数，超出请求排队（5秒超时后返回 503） |
| `SetMaxIdleConns` | 10 | 最大空闲连接数 |
| `SetConnMaxLifetime` | 1 小时 | 防止数据库端主动断开导致 EOF 错误 |
| `SetConnMaxIdleTime` | 30 分钟 | 空闲连接超时自动关闭回收 |

> 📌 **注意**：Go 应用启动时调用 `db.Ping()` 验证连接，失败则拒绝启动，不允许在数据库不可用时带病启动。

---

### 3.2 表结构设计

#### 3.2.1 用户表（users）

```sql
CREATE TABLE users (
    id            BIGSERIAL PRIMARY KEY,
    uuid          UUID NOT NULL DEFAULT gen_random_uuid(),
    phone         VARCHAR(20) NOT NULL,       -- AES-256 加密存储
    password_hash VARCHAR(100) NOT NULL,      -- Argon2id 哈希
    name          VARCHAR(50) NOT NULL,
    department    VARCHAR(100),
    role          VARCHAR(20) NOT NULL,       -- 'user' | 'admin'
    status        SMALLINT NOT NULL DEFAULT 1, -- 1 启用 | 0 禁用
    created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at    TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at    TIMESTAMPTZ                 -- 软删除
);
```

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| `id` | BIGSERIAL | PK | 自增主键，内部使用 |
| `uuid` | UUID | UNIQUE NOT NULL | 对外暴露的用户标识，不暴露自增 ID |
| `phone` | VARCHAR(20) | UNIQUE NOT NULL | 登录账号，AES-256 加密存储，响应时脱敏展示 |
| `password_hash` | VARCHAR(100) | NOT NULL | Argon2id 哈希，禁止 MD5/SHA256 |
| `role` | VARCHAR(20) | NOT NULL | 枚举：`user` / `admin` |
| `status` | SMALLINT | DEFAULT 1 | 1 启用，0 禁用。禁用后删除其全部 sessions |
| `deleted_at` | TIMESTAMPTZ | NULL | 软删除，查询默认过滤 `deleted_at IS NOT NULL` |

**索引：**
```sql
CREATE UNIQUE INDEX idx_users_uuid  ON users(uuid);
CREATE UNIQUE INDEX idx_users_phone ON users(phone) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_status_role  ON users(status, role) WHERE deleted_at IS NULL;
```

---

#### 3.2.2 会话表（sessions）

会话表是 Session 管理的核心，替代 Redis 存储登录状态：

```sql
CREATE TABLE sessions (
    id         BIGSERIAL PRIMARY KEY,
    jti        UUID NOT NULL,            -- Token 唯一标识
    user_id    BIGINT NOT NULL REFERENCES users(id),
    role       VARCHAR(20) NOT NULL,     -- 冗余存储，避免鉴权时再查 users 表
    expires_at TIMESTAMPTZ NOT NULL,     -- 过期时间
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    user_agent VARCHAR(200),             -- 登录设备信息
    ip_address INET                      -- 登录 IP
);
```

| 字段 | 类型 | 说明 |
|------|------|------|
| `jti` | UUID | 每次登录生成，是 Token 的唯一凭证 |
| `user_id` | BIGINT | 关联用户 |
| `role` | VARCHAR | 冗余存储角色，鉴权时直接使用，无需 JOIN |
| `expires_at` | TIMESTAMPTZ | 到期后视为无效，由定时任务清理过期记录 |

**索引：**
```sql
CREATE UNIQUE INDEX idx_sessions_jti     ON sessions(jti);
CREATE INDEX        idx_sessions_user_id ON sessions(user_id);
CREATE INDEX        idx_sessions_expires ON sessions(expires_at);
```

**Session 工作原理：**

```
登录：
  INSERT INTO sessions (jti, user_id, role, expires_at)
  VALUES (gen_random_uuid(), 1, 'admin', NOW() + INTERVAL '8 hours')

每次请求鉴权：
  SELECT user_id, role FROM sessions
  WHERE jti = ? AND expires_at > NOW()
  → 找到：认证通过，取出 user_id 和 role 继续处理
  → 找不到：返回 401，提示重新登录

主动退出：
  DELETE FROM sessions WHERE jti = ?

禁用用户（立即踢出所有设备）：
  DELETE FROM sessions WHERE user_id = ?

定期清理（每日凌晨定时任务）：
  DELETE FROM sessions WHERE expires_at < NOW()
```

> 📌 **为什么不用 JWT 无状态方案**：JWT 无状态方案无法主动吊销（禁用用户后 Token 仍有效直到自然过期），而本系统有严格的安全要求——管理员禁用用户后必须立即失效。数据库 Session 方案能完美支持这个需求，初期流量下性能完全足够。

---

#### 3.2.3 锁具设备表（devices）

```sql
CREATE TABLE devices (
    id              BIGSERIAL PRIMARY KEY,
    device_id       VARCHAR(32) NOT NULL,     -- 出厂唯一编号（16进制）
    name            VARCHAR(100) NOT NULL,
    location_text   TEXT NOT NULL,
    longitude       NUMERIC(10,7),
    latitude        NUMERIC(10,7),
    pipeline_tag    VARCHAR(50),              -- 归属管线标签
    risk_level      SMALLINT NOT NULL DEFAULT 1, -- 1普通 2重要 3关键
    key_encrypted   BYTEA NOT NULL,           -- K_d 的 KMS 加密副本
    key_version     SMALLINT NOT NULL DEFAULT 1,
    status          SMALLINT NOT NULL DEFAULT 1, -- 1正常 0禁用 2告警锁定
    last_active_at  TIMESTAMPTZ,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at      TIMESTAMPTZ
);
```

| 字段 | 说明 |
|------|------|
| `device_id` | 与 MCU 烧录 ID 完全一致，是硬件与软件的唯一纽带 |
| `key_encrypted` | K_d 的加密密文，由 KMS 主密钥加密存储，不存明文 |
| `key_version` | 密钥版本号，MCU 固件升级后同步递增 |
| `status` | 2 = 告警锁定，拒绝接受挑战请求，需管理员手动解除 |
| `last_active_at` | 每次 NFC 通信后更新，离线检测依据 |

**索引：**
```sql
CREATE UNIQUE INDEX idx_devices_device_id   ON devices(device_id) WHERE deleted_at IS NULL;
CREATE INDEX        idx_devices_pipeline    ON devices(pipeline_tag);
CREATE INDEX        idx_devices_status      ON devices(status) WHERE deleted_at IS NULL;
```

---

#### 3.2.4 权限授权表（permissions）

```sql
CREATE TABLE permissions (
    id          BIGSERIAL PRIMARY KEY,
    user_id     BIGINT NOT NULL REFERENCES users(id),
    device_id   BIGINT NOT NULL REFERENCES devices(id),
    granted_by  BIGINT NOT NULL REFERENCES users(id),  -- 授权操作人
    valid_from  TIMESTAMPTZ NOT NULL,
    valid_until TIMESTAMPTZ,                            -- NULL = 永久有效
    status      SMALLINT NOT NULL DEFAULT 1,            -- 1有效 0已撤销
    revoked_by  BIGINT REFERENCES users(id),
    revoked_at  TIMESTAMPTZ,
    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**索引：**
```sql
-- 保证同一用户对同一设备只有一条有效授权（幂等写入基础）
CREATE UNIQUE INDEX idx_permissions_user_device
    ON permissions(user_id, device_id)
    WHERE status = 1;

CREATE INDEX idx_permissions_user_id   ON permissions(user_id);
CREATE INDEX idx_permissions_device_id ON permissions(device_id);
CREATE INDEX idx_permissions_valid_until ON permissions(valid_until)
    WHERE valid_until IS NOT NULL AND status = 1;
```

> 📌 **幂等设计**：授权接口使用 `INSERT ... ON CONFLICT (user_id, device_id) WHERE status=1 DO UPDATE SET valid_until=excluded.valid_until`。管理员重复点击授权只会更新有效期，不会报错，也不会产生重复记录。

---

#### 3.2.5 审计日志表（audit_logs）

审计日志**只追加写入，禁止 UPDATE 和 DELETE**，采用 PostgreSQL 按月范围分区表：

```sql
CREATE TABLE audit_logs (
    id           BIGSERIAL,
    user_id      BIGINT NOT NULL,
    device_id    VARCHAR(32) NOT NULL,   -- 直接存设备ID字符串，不用FK
    action       VARCHAR(30) NOT NULL,   -- 见下方枚举
    result_code  SMALLINT NOT NULL,      -- 0成功，非0错误类型
    client_ip    INET NOT NULL,
    device_model VARCHAR(100),
    extra        JSONB,                  -- 扩展字段（失败原因等）
    occurred_at  TIMESTAMPTZ NOT NULL    -- 分区键
) PARTITION BY RANGE (occurred_at);

-- 示例：创建2026年3月分区
CREATE TABLE audit_logs_2026_03
    PARTITION OF audit_logs
    FOR VALUES FROM ('2026-03-01') TO ('2026-04-01');
```

**action 枚举：**

| 值 | 说明 |
|----|------|
| `unlock_success` | 开锁成功 |
| `unlock_fail` | 开锁失败（MCU 校验不通过） |
| `challenge_request` | 发起挑战请求 |
| `challenge_denied` | 挑战被拒绝（无权限/限流/设备锁定） |
| `auth_fail` | 登录失败 |

**分区管理策略：**
- 每月1日由定时任务自动创建下月分区
- 保留最近 180 天，超期分区整体 `DROP TABLE`（性能远优于 DELETE 行操作）
- 各分区内建索引：`idx_audit_user_id`、`idx_audit_device_id`、`idx_audit_occurred_at`

> 📌 **为什么 device_id 不用外键**：审计日志具有永久性，即使设备被删除，历史记录必须保留且可读。使用外键会导致设备删除时级联或报错，直接存 device_id 字符串可避免此问题。

---

#### 3.2.6 限流计数器表（rate_limits）

用 PostgreSQL 替代 Redis 实现限流（初期方案）：

```sql
CREATE TABLE rate_limits (
    key          VARCHAR(100) PRIMARY KEY,  -- 限流维度标识
    count        INT NOT NULL DEFAULT 1,
    window_start TIMESTAMPTZ NOT NULL,      -- 当前窗口开始时间
    updated_at   TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Key 命名规范：**

| Key 格式 | 示例 | 限流配置 |
|---------|------|---------|
| `login:ip:{ip}` | `login:ip:192.168.1.100` | 60秒内最多 10 次 |
| `challenge:{device_id}` | `challenge:LOCK-001` | 60秒内最多 5 次 |
| `admin:user:{user_id}` | `admin:user:1` | 1秒内最多 1 次批量操作 |

**限流写入逻辑（Upsert）：**

```
INSERT INTO rate_limits (key, count, window_start)
VALUES (?, 1, NOW())
ON CONFLICT (key) DO UPDATE SET
  count = CASE
    WHEN rate_limits.window_start < NOW() - INTERVAL '60 seconds'
    THEN 1                          -- 窗口已过期，重置为1
    ELSE rate_limits.count + 1      -- 窗口内累加
  END,
  window_start = CASE
    WHEN rate_limits.window_start < NOW() - INTERVAL '60 seconds'
    THEN NOW()                      -- 重置窗口起始时间
    ELSE rate_limits.window_start
  END,
  updated_at = NOW()
RETURNING count, window_start;

-- 上层逻辑：检查返回的 count 是否超过阈值
```

---

#### 3.2.7 告警记录表（alerts）

```sql
CREATE TABLE alerts (
    id          BIGSERIAL PRIMARY KEY,
    alert_type  VARCHAR(40) NOT NULL,
    device_id   VARCHAR(32) NOT NULL,
    user_id     BIGINT,
    severity    SMALLINT NOT NULL,       -- 1低 2中 3高
    status      SMALLINT NOT NULL DEFAULT 0, -- 0待处置 1已处置 2已忽略
    handled_by  BIGINT REFERENCES users(id),
    handle_note TEXT,
    extra       JSONB,
    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    handled_at  TIMESTAMPTZ
);
```

**索引：**
```sql
CREATE INDEX idx_alerts_status          ON alerts(status) WHERE status = 0;
CREATE INDEX idx_alerts_device_created  ON alerts(device_id, created_at DESC);
CREATE INDEX idx_alerts_severity_status ON alerts(severity, status);
```

---

#### 3.2.8 管理员操作日志表（operation_logs）

记录管理员在 Web 平台的所有管理操作，与开锁审计分表存储：

```sql
CREATE TABLE operation_logs (
    id              BIGSERIAL PRIMARY KEY,
    operator_id     BIGINT NOT NULL,
    action          VARCHAR(50) NOT NULL,    -- grant_permission / revoke_permission 等
    target_type     VARCHAR(20) NOT NULL,    -- user / device / permission
    target_id       BIGINT NOT NULL,
    before_snapshot JSONB,                   -- 变更前快照，支持操作回溯
    after_snapshot  JSONB,
    occurred_at     TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

---

#### 3.2.9 连续失败计数表（device_fail_counts）

追踪设备连续开锁失败次数，触发告警阈值：

```sql
CREATE TABLE device_fail_counts (
    device_id    VARCHAR(32) PRIMARY KEY,
    count        INT NOT NULL DEFAULT 0,
    last_fail_at TIMESTAMPTZ NOT NULL,
    updated_at   TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

每次失败：`INSERT ... ON CONFLICT DO UPDATE SET count = count + 1`
每次成功：`UPDATE SET count = 0`
达到阈值（count >= 3）：触发告警流程，更新 devices.status = 2

---

### 3.3 数据库 ER 关系图

```
users ──────────────────────────────────────────┐
  │                                              │
  │ 1:N                                          │ (granted_by / revoked_by)
  ▼                                              │
sessions                                         │
                                                 │
users ──────────── permissions ──────── devices  │
  │         N:M        │                  │      │
  │                    │                  │      │
  │                    └──────────────────┘      │
  │                                              │
  ├── audit_logs (user_id + device_id 字符串)    │
  │                                              │
  ├── operation_logs (operator_id)               │
  │                                              │
  └── alerts (user_id)     devices ──── device_fail_counts
                                    └── alerts (device_id)
```

---

## 4. Session 会话管理设计

### 4.1 为什么需要 Session 管理

HTTP 协议是无状态的，服务器无法天然识别"这个请求是谁发的"。Session 管理解决三个核心问题：

1. **身份持久化**：用户登录一次后，后续请求自动识别身份，无需反复输入密码
2. **主动吊销**：用户退出登录或被管理员禁用后，该会话立即失效
3. **登录超时**：长时间不活跃的会话自动过期，防止 Token 永久有效带来的安全风险

### 4.2 完整登录流程

```
① 用户提交 {phone, password}
       │
② 查询 users WHERE phone=? AND deleted_at IS NULL
   （无论用户是否存在，均执行 Argon2id 验证，防止时序攻击）
       │
③ 比对密码哈希
   失败 → 返回 1001「账号或密码错误」（不区分用户不存在/密码错误）
       │
④ 检查 status = 1
   禁用 → 返回 1002「账号已被禁用」
       │
⑤ 生成 JTI = UUID v4
   INSERT INTO sessions (jti, user_id, role, expires_at, ...)
   expires_at = NOW() + INTERVAL '8 hours'
       │
⑥ 构建 Token（包含 user_uuid 和 jti 的签名字符串）
   返回 Token 给客户端
```

### 4.3 鉴权中间件逻辑

每个需要登录的接口都经过此中间件：

```
① 解析 Authorization: Bearer <token>
   格式错误 → 401
       │
② 从 token 解析出 user_uuid 和 jti
       │
③ SELECT user_id, role FROM sessions
   WHERE jti = $1 AND expires_at > NOW()
   未找到（已过期或已登出）→ 401「会话已过期，请重新登录」
       │
④ 额外检查：查询 users.status WHERE id = user_id
   status = 0（账号在本次请求前刚被禁用）
   → 执行 DELETE FROM sessions WHERE user_id = ?
   → 返回 401「账号已被禁用」
       │
⑤ 将 user_id、role 注入 Gin Context
   后续所有处理器直接从 Context 读取，无需再查数据库
```

### 4.4 退出登录

```
用户 POST /api/auth/logout

DELETE FROM sessions WHERE jti = ?
→ 记录被删除，该 Token 立即失效
→ 返回 200

攻击者拿着这个 Token 再次请求：
  SELECT ... WHERE jti = ? → 找不到 → 401
```

### 4.5 禁用用户（强制踢出所有设备）

```
管理员禁用 user_id=5：

① UPDATE users SET status=0 WHERE id=5   （标记禁用）
② DELETE FROM sessions WHERE user_id=5   （清除全部会话）
③ INSERT INTO operation_logs ...          （记录操作）

user_id=5 在任何设备上的下次请求：
  Token 仍然存在（可能） → 但步骤④额外检查 users.status → 发现 status=0
  → 清除残余 sessions → 返回 401
```

---

## 5. 限流控制设计

### 5.1 为什么需要限流

没有限流的系统面临两类威胁：

- **暴力破解**：攻击者脚本每秒发送大量请求逐一尝试密码组合
- **恶意探测**：攻击者反复对锁具设备发送挑战请求，探测系统行为或消耗 CPU 资源

### 5.2 限流工作原理

限流的核心是**滑动窗口计数**：在指定时间窗口内，同一来源的请求不能超过 N 次，超过则拒绝，窗口过期后计数自动重置。

```
以「挑战接口 60秒内最多5次」为例：

时间轴：
0s  → 第1次请求，count=1  ✅
10s → 第2次请求，count=2  ✅
20s → 第3次请求，count=3  ✅
30s → 第4次请求，count=4  ✅
40s → 第5次请求，count=5  ✅
45s → 第6次请求，count=6  ❌ 429 拒绝
55s → 第7次请求，count=7  ❌ 429 拒绝

60s → 窗口过期，重置 count=1，window_start=60s
70s → 第9次请求，count=2  ✅（新窗口）
```

### 5.3 各接口限流配置

| 接口 | 限流维度 | 阈值 | 超限处理 |
|------|---------|------|---------|
| `POST /api/auth/login` | IP | 10次/60秒 | 429，超限5次后锁定IP 10分钟 |
| `POST /api/lock/challenge` | device_id | 5次/60秒 | 429，同时触发 challenge_flood 告警 |
| `POST /api/admin/permissions`（批量） | user_id | 1次/秒 | 429 |
| `GET /api/admin/audit-logs`（导出） | user_id | 1次/分钟 | 429 |
| 其他所有接口 | IP | 100次/分钟 | 429 + Retry-After 响应头 |

### 5.4 PostgreSQL 限流实现

使用 rate_limits 表（见 §3.2.6），核心是一条原子 Upsert SQL：

```
每次请求到来：

1. 执行 Upsert（见 §3.2.6 的 SQL）
2. 检查返回的 count 值：
   count <= 阈值 → 放行
   count >  阈值 → 返回 429

注意：Upsert 使用 PostgreSQL 行锁，高并发下自动串行化，
      不存在计数不准确的问题（这是 PostgreSQL 原子操作的保证）
```

### 5.5 IP 封锁（登录接口专用）

登录接口需要额外的 IP 封锁机制（防止攻击者换时间窗口继续攻击）：

```sql
CREATE TABLE ip_blocks (
    ip          INET PRIMARY KEY,
    blocked_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at  TIMESTAMPTZ NOT NULL,
    reason      VARCHAR(100)
);
```

鉴权中间件在 rate_limits 检查前，先查询此表：

```
SELECT 1 FROM ip_blocks WHERE ip = ? AND expires_at > NOW()
→ 存在 → 403「IP 已被临时封锁」
→ 不存在 → 继续后续处理
```

---

## 6. 核心业务逻辑设计

### 6.1 挑战-应答协议服务端实现

#### POST /api/lock/challenge — 提交挑战数（8步安全校验，不可省略）

**请求参数：**

```json
{
  "device_id": "LOCK-001",
  "challenge_c": "a3f2b1c4d5e6f7a8",
  "timestamp": 1708300000
}
```

**处理步骤：**

| 步骤 | 校验项 | 失败返回 |
|------|-------|---------|
| 1 | 鉴权中间件已通过，取出 user_id 和 role | 401 |
| 2 | challenge_c 必须为 16 位十六进制字符串（8字节） | 4001 参数错误 |
| 3 | timestamp 与服务端时间差 ≤ 30 秒（防旧请求重放） | 4002 请求已过期 |
| 4 | 查询 devices WHERE device_id=?，设备必须存在 | 3001 设备不存在 |
| 5 | devices.status 必须为 1（正常），0=禁用，2=告警锁定 | 3002 设备不可用 |
| 6 | 查 permissions 表，验证用户对该设备有有效授权 | 2001 无操作权限 |
| 7 | 限流检查：执行 rate_limits Upsert，超过 5次/60秒 | 3003 请求过于频繁 |
| 8 | 从 KMS 解密 devices.key_encrypted 取得 K_d，计算 Response = AES-128-CMAC(K_d, C \|\| device_id \|\| user_id \|\| timestamp) | 5001 内部错误 |

**成功响应：**

```json
{
  "code": 0,
  "data": {
    "response": "f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6"
  }
}
```

**异步操作（不阻塞响应）：**
- 向 RabbitMQ `audit.queue` 投递挑战请求记录
- 更新 devices.last_active_at（可延迟更新，批量合并）

> 📌 **安全要点**：K_d 解密后仅存在于函数调用栈内存中，计算完成后由 GC 回收，绝不写入任何日志、缓存或响应体。

---

#### POST /api/lock/report — 上报开锁结果

**请求参数：**

```json
{
  "device_id": "LOCK-001",
  "result": "success",
  "fail_reason": "",
  "occurred_at": 1708300003,
  "device_model": "iPhone 15"
}
```

**处理步骤：**

```
result = "fail"：
  → UPDATE device_fail_counts SET count = count + 1
  → IF count >= 3：
      UPDATE devices SET status = 2（告警锁定）
      INSERT INTO alerts (alert_type='consecutive_fail', ...)
      向 RabbitMQ notify.queue 投递告警通知消息

result = "success"：
  → UPDATE device_fail_counts SET count = 0（重置连续失败计数）
  → UPDATE devices SET last_active_at = NOW()

→ 向 RabbitMQ audit.queue 投递审计日志消息（异步，不阻塞响应）
→ 返回 200
```

---

### 6.2 权限管理逻辑

#### 授权操作

```
① RBAC 中间件：确认操作者为 admin
② 验证目标用户和设备均存在且未删除
③ 执行 Upsert（幂等）：
   INSERT INTO permissions (user_id, device_id, granted_by, valid_from, valid_until)
   ON CONFLICT (user_id, device_id) WHERE status=1
   DO UPDATE SET valid_until = excluded.valid_until
④ INSERT INTO operation_logs（记录操作快照）
```

#### 撤销授权

```
① UPDATE permissions SET status=0, revoked_by=?, revoked_at=NOW()
② INSERT INTO operation_logs
```

**撤销生效时机：**

撤销完成后，该用户下次发起挑战请求时，步骤6（权限查询）查到 `status=0`，拒绝计算 Response，MCU 无法收到合法应答，开锁失败。无需等待缓存过期，**权限撤销实时生效**。

---

## 7. 并发控制设计

### 7.1 并发场景与风险识别

| 并发场景 | 风险等级 | 说明 |
|---------|---------|------|
| 同一设备同时收到多个挑战请求 | 高 | 限流计数器可能不准确 |
| 管理员禁用用户与该用户请求并发 | 高 | 可能绕过禁用检查 |
| 权限撤销与挑战请求并发 | 高 | 极短时间窗口内权限可能未实时生效 |
| 重复授权写入 | 中 | 快速重复点击可能插入重复记录 |
| 审计日志高并发写入 | 中 | 直接同步写库可能导致写入瓶颈 |

### 7.2 各场景控制方案

#### 限流计数器并发（PostgreSQL 行锁保证原子性）

rate_limits 表的 Upsert 操作利用 PostgreSQL 的行级锁：

```
ON CONFLICT (key) DO UPDATE ...

PostgreSQL 在执行 Upsert 时自动对该行加排他锁（FOR UPDATE 语义），
同一个 key 的并发 Upsert 请求会串行化执行，计数器不会出现"两个请求
同时读到 count=4，同时写入 count=5，导致计数少1"的问题。
```

#### 禁用用户与请求并发（状态二次校验）

鉴权中间件第④步额外检查 `users.status`（见 §4.3），即使 Session 记录还在，也会发现用户已被禁用并拒绝请求。这个检查有极短的时间窗口（Session 查询与 status 查询之间），但考虑到 DELETE sessions 和 UPDATE users 几乎同时发生，实际风险可忽略。

#### 重复授权（唯一约束 + Upsert）

permissions 表在 `(user_id, device_id) WHERE status=1` 上建立唯一索引：

```
即使 100 个并发请求同时提交相同的授权：
- 只有第1个请求成功 INSERT
- 后续请求触发 ON CONFLICT，执行 DO UPDATE（更新有效期）
- 没有任何请求会报错，也不会产生重复记录
```

#### 审计日志高并发写入（RabbitMQ 异步解耦）

主流程不直接写审计日志到 PostgreSQL，而是异步投递到消息队列：

```
主流程：
  向 RabbitMQ audit.queue 投递消息（< 1ms）→ 立即返回响应

Audit Consumer（独立 Goroutine 池）：
  批量消费消息
  每 100 条 或 每 1 秒 触发一次批量写入（PostgreSQL COPY 协议）
  
优势：
  - 主流程响应时间不受数据库写入压力影响
  - 峰值时消息队列自然削峰，数据库始终平稳写入
  - Consumer 失败时消息重试，不丢失
```

### 7.3 数据库事务边界

需要保证原子性的操作必须在同一事务内执行：

```
触发告警锁定（device_fail_counts 达阈值）：

BEGIN TRANSACTION
  UPDATE devices SET status=2 WHERE device_id=?
  INSERT INTO alerts (...)
  UPDATE device_fail_counts SET count=0 WHERE device_id=?
COMMIT

如果任何一步失败，整体回滚，不会出现"设备已锁定但告警未记录"的不一致状态。
```

---

## 8. 接口设计规范

### 8.1 接口总表

| 接口名称 | 方法 | 路径 | 鉴权 | 说明 |
|---------|------|------|------|------|
| 用户登录 | POST | `/api/auth/login` | 无 | 返回会话 Token |
| 退出登录 | POST | `/api/auth/logout` | 登录用户 | 删除 Session 记录 |
| 获取授权设备列表 | GET | `/api/lock/devices` | 登录用户 | 返回当前用户有权操作的锁具 |
| 提交挑战数 | POST | `/api/lock/challenge` | 登录用户 | 核心接口，返回 Response |
| 上报开锁结果 | POST | `/api/lock/report` | 登录用户 | 写入审计日志 |
| 用户列表 | GET | `/api/admin/users` | 管理员 | 分页+筛选 |
| 创建用户 | POST | `/api/admin/users` | 管理员 | 初始密码短信下发 |
| 更新用户 | PUT | `/api/admin/users/:uuid` | 管理员 | 禁用时同步删除 sessions |
| 重置密码 | POST | `/api/admin/users/:uuid/reset-pwd` | 管理员 | 随机密码短信通知 |
| 锁具列表 | GET | `/api/admin/devices` | 管理员 | 分页+筛选 |
| 创建/更新锁具 | POST/PUT | `/api/admin/devices` | 管理员 | K_d 上传后即时 KMS 加密 |
| 权限授权 | POST | `/api/admin/permissions` | 管理员 | Upsert，支持批量（≤100条） |
| 撤销权限 | DELETE | `/api/admin/permissions/:id` | 管理员 | 实时生效 |
| 审计日志查询 | GET | `/api/admin/audit-logs` | 管理员 | 多维筛选+分页，支持 CSV 导出 |
| 告警列表 | GET | `/api/admin/alerts` | 管理员 | 按状态/设备/时间筛选 |
| 处置告警 | PUT | `/api/admin/alerts/:id` | 管理员 | 标记处置，可同时解除设备锁定 |
| Dashboard 数据 | GET | `/api/admin/dashboard` | 管理员 | 总览统计+最新告警 |
| 健康检查 | GET | `/api/health` | 无 | 返回服务状态，供 CI/CD 验证 |

### 8.2 分页规范

所有列表接口统一使用**游标分页**（Keyset Pagination），而非 OFFSET 分页：

**原因**：OFFSET 在大数据量下性能随页数增大线性下降（全表扫描），游标分页性能恒定。

**请求参数：**

```
GET /api/admin/audit-logs?cursor=1708300000000_12345&limit=20&device_id=LOCK-001
```

| 参数 | 类型 | 说明 |
|------|------|------|
| `cursor` | string | 上一页最后一条记录的排序字段值组合，首次请求不传 |
| `limit` | int | 每页条数，默认 20，最大 100 |

**响应结构：**

```json
{
  "code": 0,
  "data": {
    "items": [...],
    "next_cursor": "1708299000000_12340",
    "has_more": true
  }
}
```

> 📌 **设计约束**：游标分页不支持"跳页"操作，前端只提供「加载更多」或「下一页」按钮，不提供页码导航，这是该方案的固有限制，可接受。

### 8.3 CSV 导出异步处理

审计日志导出为重型操作，采用异步处理：

```
① 用户 GET /api/admin/audit-logs?export=true&...
② 服务端立即返回任务 ID：{"task_id": "export-xxx"}
③ 后台 Goroutine 执行查询和文件生成
④ 前端轮询 GET /api/admin/export-tasks/{task_id}
   → status: pending / processing / done / failed
   → done 时返回 download_url（预签名 URL，10 分钟有效）
⑤ 前端自动触发文件下载
```

---

## 9. 消息队列设计

### 9.1 RabbitMQ 队列规划

| 队列名 | 类型 | 消费者 | 说明 |
|--------|------|--------|------|
| `audit.queue` | Durable | Audit Consumer（3 Worker） | 开锁审计日志，批量写入 audit_logs |
| `notify.queue` | Durable | Notify Consumer（2 Worker） | 告警通知（App Push / 邮件 / 短信） |
| `audit.dlq` | Durable | 人工处理 | audit.queue 死信队列，重试3次失败后路由至此 |
| `notify.dlq` | Durable | 人工处理 | notify.queue 死信队列 |

### 9.2 消息结构规范

**公共消息头：**

```json
{
  "message_id": "uuid-v4",
  "version": "1.0",
  "source": "lock-service",
  "occurred_at": 1708300000000
}
```

**audit.queue 消息体：**

```json
{
  "user_id": 1,
  "device_id": "LOCK-001",
  "action": "unlock_success",
  "result_code": 0,
  "client_ip": "192.168.1.100",
  "device_model": "iPhone 15",
  "extra": {}
}
```

**notify.queue 消息体：**

```json
{
  "alert_id": 42,
  "alert_type": "consecutive_fail",
  "device_id": "LOCK-001",
  "severity": 3,
  "targets": [
    {"type": "push", "address": "device_token_xxx"},
    {"type": "sms",  "address": "138xxxx8888"}
  ],
  "template_data": {"fail_count": 3, "device_name": "3号管线东侧截止阀"}
}
```

### 9.3 消费者可靠性设计

- **手动 ACK**：消费者处理完成后才 ACK，处理失败则 NACK，消息不丢失
- **死信路由**：NACK 超过 3 次（指数退避重试）后自动路由到 DLQ
- **Prefetch Count = 10**：限制单个 Consumer 同时处理消息数，防止内存积压
- **Durable Queue + Persistent Message**：服务重启后消息不丢失
- **告警通知聚合**：同一设备同类型告警，10 分钟内只发送一次通知（notify.queue 投递前去重检查）

---

## 10. 安全设计

### 10.1 密钥管理（KMS）

设备密钥 K_d 是系统安全的最终依赖，必须独立保护：

| 层面 | 措施 |
|------|------|
| 存储 | `devices.key_encrypted` 存储 K_d 的 AES-256-GCM 加密密文，由 KMS 主密钥加密 |
| 使用 | 计算 Response 时调用 KMS SDK 实时解密，K_d 明文仅在函数栈内存中，计算后置零 |
| 主密钥 | 阿里云 KMS 或自建 HashiCorp Vault 管理，应用进程无法导出主密钥 |
| 审计 | 每次 K_d 解密操作由 KMS 记录，异常频率触发安全告警 |
| 禁止 | K_d 明文绝对禁止出现在日志、HTTP 响应、错误信息、缓存中 |

### 10.2 密码安全

- **算法**：Argon2id，参数：`memory=65536（64MB）`、`iterations=3`、`parallelism=4`
- **禁止使用**：MD5、SHA-1、SHA-256 直接哈希密码
- **强度要求**：最短 8 位，包含大小写字母和数字，后端强制校验（不依赖前端）
- **初始密码**：服务端随机生成 16 位，通过短信下发，HTTP 响应中不返回

### 10.3 传输安全

- 全站强制 HTTPS（TLS 1.2+）
- Nginx 配置 `Strict-Transport-Security: max-age=31536000; includeSubDomains`
- 禁用弱加密套件（RC4、3DES）
- API 响应必须包含：`X-Content-Type-Options: nosniff`、`X-Frame-Options: DENY`、`Content-Security-Policy`

### 10.4 输入校验与注入防御

- 所有用户输入通过 Gin Binding Tag 结构体级别校验，失败统一返回 400
- GORM 全程使用参数化查询，禁止字符串拼接 SQL
- JSONB 字段写入前验证结构，防止超大 JSON 注入
- 文件上传：严格校验 MIME Type、文件大小（≤10MB）

### 10.5 敏感数据脱敏

| 数据类型 | 脱敏规则 |
|---------|---------|
| 手机号 | 数据库加密存储，API 响应中展示为 `138****8888` |
| 密码 | Argon2id 哈希后存储，任何接口均不返回密码字段 |
| K_d | 绝对禁止在任何输出中出现 |
| 日志中的敏感字段 | Zap 中间件自动将 `password`、`key`、`token` 等字段替换为 `[REDACTED]` |

---

## 11. 告警系统设计

### 11.1 告警触发规则

| 告警类型 | 触发条件 | 严重级别 | 自动处置动作 |
|---------|---------|---------|------------|
| `consecutive_fail` | 同设备连续校验失败 ≥ 3 次 | 高（3） | 设备 status=2（告警锁定），拒绝后续挑战 |
| `challenge_flood` | 同设备 60s 内挑战请求 > 5 次 | 高（3） | 限流拒绝，写入告警，推送通知 |
| `off_hours_attempt` | 非工作时段（22:00~06:00）有开锁操作 | 中（2） | 仅记录，不阻断，推送通知 |
| `device_offline` | `last_active_at` 超过 30 天未更新 | 低（1） | 定时任务批量生成，汇总推送 |

### 11.2 告警通知渠道

优先级依次降级：**App Push → 短信 → 邮件**

- **App Push**：个推/极光 SDK，实时推送；设备离线时降级短信
- **短信**：阿里云短信 SDK；同一设备同类型 1 分钟内最多 1 条（防告警风暴）
- **邮件**：SMTP 发送；低优先级告警或每日汇总报表

### 11.3 告警处置流程

```
管理员在 Web 平台看到告警 → 点击「处置」→ 填写处置备注
  ↓
UPDATE alerts SET status=1, handled_by=?, handle_note=?, handled_at=NOW()
  ↓
如果是 consecutive_fail 类型：
  UPDATE devices SET status=1（解除告警锁定）
  ↓
INSERT INTO operation_logs（记录处置操作）
```

---

## 12. 前端架构设计（Vue 3 管控平台）

### 12.1 技术栈

| 组件 | 选型 | 说明 |
|------|------|------|
| 框架 | Vue 3 + TypeScript + Vite | 组合式 API，类型安全，构建速度快 |
| UI 组件库 | Ant Design Vue | 企业后台表格、表单、权限矩阵完善 |
| 状态管理 | Pinia | Vue 3 官方推荐，比 Vuex 轻量 |
| HTTP 客户端 | Axios | 拦截器机制完善 |
| 图表 | ECharts 5 | 趋势图、热力图 |
| 地图 | 高德地图 JS API | 国内坐标系（GCJ-02）支持 |

### 12.2 目录结构规范

```
src/
├── api/                  # 接口请求封装（按模块）
│   ├── auth.ts           # 登录/登出
│   ├── lock.ts           # 挑战/上报/设备列表
│   └── admin.ts          # 用户/设备/权限/日志/告警管理
├── stores/               # Pinia 状态管理
│   ├── auth.ts           # 会话信息（user_id/role/token）
│   ├── ui.ts             # 全局 loading/toast 状态
│   └── alert.ts          # 告警列表状态（轮询）
├── views/                # 页面级组件（路由直接映射）
│   ├── Login.vue
│   ├── Dashboard.vue
│   ├── Users.vue
│   ├── Devices.vue
│   ├── Permissions.vue
│   ├── AuditLogs.vue
│   └── Alerts.vue
├── components/           # 通用业务组件（无业务逻辑，props 驱动）
│   ├── DeviceStatusBadge.vue
│   ├── AlertSeverityTag.vue
│   └── PermissionMatrix.vue
├── composables/          # 可复用逻辑 Hook
│   ├── usePagedList.ts   # 游标分页通用逻辑
│   ├── useAlertPolling.ts # 告警轮询（30秒间隔）
│   └── usePermissionCheck.ts
├── router/               # 路由配置 + 路由守卫
├── utils/                # 工具函数（时间格式化/脱敏/下载）
└── types/                # TypeScript 类型定义
```

### 12.3 HTTP 客户端封装规范

所有接口调用通过统一 Axios 实例：

```
请求拦截器：
  - 自动注入 Authorization: Bearer {token}（从 Pinia auth store 读取）
  - 注入 X-Request-ID（前端生成 UUID）

响应拦截器：
  - 统一解包 {code, message, data} 结构
  - code=1001/1002（会话过期/账号禁用）→ 清除本地 token → 跳转登录页
  - code=2xxx（权限不足）→ 弹出提示，不跳转
  - HTTP 5xx → 弹出「服务异常，请稍后重试」
  - 网络超时 → 自动重试 2 次（指数退避），4xx 不重试

超时配置：
  - 默认接口：10 秒
  - 文件导出接口：60 秒
```

### 12.4 路由权限控制

```typescript
// 路由 meta 声明所需角色
{ path: '/users', meta: { roles: ['admin'] } }
{ path: '/devices', meta: { roles: ['admin'] } }

// 路由守卫（beforeEach）
1. 检查 Pinia auth store 中是否有 token
   → 无 token → 跳转 /login
2. 检查 meta.roles 与当前用户 role 是否匹配
   → 不匹配 → 跳转 /403
3. 登录页在已登录状态访问 → 重定向 /dashboard
```

### 12.5 关键页面设计要点

#### Dashboard 页面

- 页面加载时并发请求总览统计和最新告警列表（`Promise.all`，不串行）
- 告警列表每 30 秒自动轮询（`useAlertPolling` composable），新增高级告警时顶部浮动通知
- ECharts 图表懒加载，滚动到可视区域时动态 `import`，不影响首屏速度

#### 权限矩阵页面

- 采用虚拟滚动渲染用户×设备矩阵，避免大量 DOM 节点导致页面卡顿
- 权限变更使用乐观更新（先更新本地状态再请求接口，失败时回滚）
- 批量授权：选择多行 → 「批量授权」→ 收集变更列表 → 单次 API 调用（最多 100 条）

#### 审计日志页面

- 游标分页，「加载更多」模式，不显示页码
- 导出功能：轮询服务端下载链接，就绪后自动触发下载
- 高危行（连续失败/非工作时段）标红，失败行标橙色

---

## 13. 日志与可观测性

### 13.1 结构化日志规范（Zap）

Go 服务端全程使用 Zap JSON 格式日志，禁止 `fmt.Println` 或标准 `log` 包：

| 级别 | 使用场景 | 包含字段 |
|------|---------|---------|
| DEBUG | 开发调试 | 详细步骤，**生产环境关闭** |
| INFO | 正常业务流 | `{request_id, user_id, action, device_id, latency_ms}` |
| WARN | 可恢复异常 | `{request_id, reason}`：限流触发、校验失败 |
| ERROR | 需关注错误 | `{request_id, error, stack_trace}`：DB 连接失败、KMS 异常 |

### 13.2 Grafana Loki 日志聚合

- Promtail 以 Sidecar 方式部署，监听服务标准输出，推送至 Loki
- Label 规划：`{app="lock-service", env="prod", level="error"}`
- Grafana 告警规则：ERROR 日志 1 分钟内超过 10 条，触发邮件通知运维

### 13.3 Prometheus 指标监控

服务端暴露 `/metrics` 端点，收集以下指标：

| 指标名 | 类型 | 说明 |
|--------|------|------|
| `http_request_duration_seconds` | Histogram | HTTP 请求耗时，按路由和状态码分组 |
| `lock_challenge_total` | Counter | 挑战请求计数，按 result 分组 |
| `active_sessions_total` | Gauge | 当前活跃 Session 数（定期查 sessions 表） |
| `db_pool_open_connections` | Gauge | 数据库连接池当前打开连接数，>40 告警 |
| `mq_queue_depth` | Gauge | RabbitMQ 各队列积压消息数，>1000 告警 |

---

## 14. 部署架构设计

### 14.1 容器化部署方案

初期采用 Docker Compose 单机部署：

| 服务 | 副本数 | 资源限制 | 说明 |
|------|--------|---------|------|
| `lock-service`（Go） | 2 | 1核/512MB | Alpine 基础镜像，镜像约 20MB；Nginx upstream 负载均衡 |
| `nginx` | 1 | 0.5核/128MB | 反向代理 + 静态文件（Vue 构建产物）+ TLS 终止 |
| `postgresql` | 1主+1备 | 2核/2GB | 主从流式复制，备库用于只读查询（报表/导出） |
| `rabbitmq` | 1 | 0.5核/512MB | 启用管理控制台（15672，仅内网） |
| `grafana+loki+prometheus` | 各1 | 0.5核/256MB | 监控栈，仅内网访问 |

### 14.2 网络安全组规则

| 允许来源 | 目标端口 | 说明 |
|---------|---------|------|
| 互联网（0.0.0.0/0） | 443（HTTPS） | 唯一对外开放端口 |
| 互联网（0.0.0.0/0） | 80（HTTP） | 仅 ACME 证书续签，其余 301 重定向 |
| 内网服务间 | 8080（Go 服务） | Nginx 转发，不对外暴露 |
| 内网服务间 | 5432（PostgreSQL） | 仅 Go 服务和 PgBouncer 可访问 |
| 内网服务间 | 5672（RabbitMQ） | 仅 Go 服务可访问 |
| 运维 IP 白名单 | 22（SSH） | 仅允许堡垒机 IP，密钥认证，禁止密码登录 |

### 14.3 CI/CD 流水线

```
代码 Push 到 main 分支
  │
  ▼
Stage 1：质量检查
  go test ./...        （单元测试）
  golangci-lint run    （静态分析）
  npm run build        （前端构建）
  │
  ▼
Stage 2：构建镜像
  docker build -t lock-service:{git-sha} .
  docker push 私有镜像仓库
  │
  ▼
Stage 3：部署（main 分支）
  ssh 部署服务器
  docker pull lock-service:{git-sha}
  docker-compose up -d --no-deps lock-service
  （滚动更新，零停机）
  │
  ▼
Stage 4：健康检查
  连续调用 GET /api/health 3次成功 → Pipeline 通过
  失败 → 自动回滚到上一版本镜像
```

### 14.4 数据备份策略

| 数据类型 | 频率 | 方式 | 保留策略 |
|---------|------|------|---------|
| PostgreSQL 全量 | 每日 02:00 | `pg_dump` 压缩上传 OSS | 保留最近 30 份 |
| PostgreSQL WAL 归档 | 持续 | WAL 日志归档至 OSS | 支持任意时间点恢复（PITR） |
| 应用配置 | 变更时 | Git 版本控制（密钥除外） | 永久保留 |

---

## 15. Redis 弹性扩展方案

### 15.1 引入 Redis 的判断标准

出现以下**任意一个**信号时引入 Redis：

| 监控信号 | 阈值 | 含义 |
|---------|------|------|
| 接口 P95 响应时间 | > 500ms | DB 查询成为瓶颈 |
| PostgreSQL CPU | 持续 > 60% | 查询压力过大 |
| 并发用户数 | 超过 200 | sessions 表写入开始有锁竞争 |
| sessions 表查询占总 QPS | > 30% | 值得用缓存优化 |

在以上信号出现之前，一台 PostgreSQL + 两个 Go 实例完全可以支撑业务运行，**不要提前引入不必要的复杂度**。

### 15.2 如何平滑迁移

之所以现在就能平滑迁移，是因为数据访问层已经通过接口隔离：

```
当前（PostgreSQL 实现）：
  SessionStore 接口
    → PostgresSessionStore（查 sessions 表）

迁移后（Redis 实现）：
  SessionStore 接口
    → RedisSessionStore（查 Redis）

业务代码完全不感知变化，只需：
  1. 新增 RedisSessionStore 实现
  2. 修改依赖注入配置
  3. 上线，无需改任何业务逻辑
```

### 15.3 迁移后各 Key 的对应关系

| 当前（PostgreSQL） | 迁移后（Redis Key） | TTL |
|-------------------|-------------------|-----|
| sessions 表 | `session:{user_uuid}` | 8小时 |
| 无（DELETE 实现） | `session_blacklist:{jti}` | 剩余有效期 |
| rate_limits 表 | `challenge_rate:{device_id}` | 60秒 |
| device_fail_counts 表 | `fail_count:{device_id}` | 10分钟 |
| 直接查 permissions | `perm_cache:{user_id}` | 5分钟 |
| 直接查 devices | `device_status:{device_id}` | 30秒 |

---

## 16. 性能基准与测试要求

### 16.1 性能指标基准

| 指标项 | P95 目标 | P99 目标 | 备注 |
|--------|---------|---------|------|
| `POST /api/lock/challenge` | ≤ 300ms | ≤ 500ms | 含 DB 查询 + KMS 解密 + CMAC 计算 |
| `POST /api/auth/login` | ≤ 800ms | ≤ 1200ms | Argon2id 故意慢（防暴力破解），不可优化 |
| `GET /api/lock/devices` | ≤ 150ms | ≤ 300ms | 直接查 permissions 表 |
| `GET /api/admin/dashboard` | ≤ 300ms | ≤ 600ms | 聚合 SQL |
| 并发用户数 | 200 同时在线 | — | 压测持续 5 分钟，错误率 < 0.1% |
| 审计日志写入吞吐 | 500条/秒 | — | 异步写入，MQ 批量落库 |

### 16.2 测试要求

| 测试类型 | 要求 |
|---------|------|
| 单元测试 | Service 层核心函数覆盖率 ≥ 80%；挑战-应答计算函数覆盖率 **100%**（含所有错误路径） |
| 集成测试 | 使用 Testcontainers 启动真实 PostgreSQL 容器，测试 DB 操作和事务边界 |
| API 测试 | 覆盖所有接口的正常路径和主要错误路径（参数错误/无权限/限流） |
| 并发测试 | k6 脚本，模拟 200 并发，持续 5 分钟混合场景（登录10%、挑战50%、查询40%） |
| 安全测试 | OWASP ZAP 自动扫描（集成进 CI），验证 SQL 注入、XSS 防御 |

---

## 版本记录

| 版本 | 日期 | 变更说明 |
|------|------|---------|
| V1.0 | 2026-02-19 | 初版，依据 SRS V1.2 编写；初期采用 Go + PostgreSQL 精简架构，Redis 作为弹性扩展选项；详细说明 Session 管理和限流计数器的 PostgreSQL 实现方案 |

---

> ※ 本文档为技术设计基准版本，开发过程中如遇方案调整，须同步更新并记录变更历史。